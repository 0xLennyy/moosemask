// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v3.20.3
// source: data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { P2PChannelEnvelope } from "./channel";
import { ClockFrame, ClockFramesPreflight, ClockFramesRequest } from "./clock";
import { Ed448Signature } from "./keys";
import { MintCoinRequest } from "./node";

export const protobufPackage = "quilibrium.node.data.pb";

export interface DataPeerListAnnounce {
  peerList: DataPeer[];
}

export interface DataPeer {
  peerId: Uint8Array;
  multiaddr: string;
  maxFrame: Long;
  timestamp: Long;
  version: Uint8Array;
  signature: Uint8Array;
  publicKey: Uint8Array;
  totalDistance: Uint8Array;
}

export interface DataCompressedSync {
  fromFrameNumber: Long;
  toFrameNumber: Long;
  truncatedClockFrames: ClockFrame[];
  proofs: InclusionProofsMap[];
  segments: InclusionSegmentsMap[];
}

export interface SyncRequestAuthentication {
  peerId: Uint8Array;
  challenge: Uint8Array;
  response: Ed448Signature | undefined;
}

export interface DataCompressedSyncRequestMessage {
  preflight?: ClockFramesPreflight | undefined;
  request?: ClockFramesRequest | undefined;
  authentication?: SyncRequestAuthentication | undefined;
}

export interface DataCompressedSyncResponseMessage {
  preflight?: ClockFramesPreflight | undefined;
  response?: DataCompressedSync | undefined;
}

export interface InclusionProofsMap {
  frameCommit: Uint8Array;
  proof: Uint8Array;
  commitments: InclusionCommitmentsMap[];
}

export interface InclusionSegmentsMap {
  hash: Uint8Array;
  data: Uint8Array;
}

export interface InclusionCommitmentsMap {
  commitment: Uint8Array;
  typeUrl: string;
  segmentHashes: Uint8Array[];
}

export interface GetDataFrameRequest {
  frameNumber: Long;
}

export interface DataFrameResponse {
  clockFrame: ClockFrame | undefined;
  proof: Uint8Array;
}

export interface PreMidnightMintResponse {
  address: Uint8Array;
  increment: number;
}

export interface PreMidnightMintStatusRequest {
  owner: Uint8Array;
}

export interface FrameRebroadcast {
  from: Long;
  to: Long;
  clockFrames: ClockFrame[];
  random: Uint8Array;
}

export interface ChallengeProofRequest {
  peerId: Uint8Array;
  clockFrame: ClockFrame | undefined;
}

export interface ChallengeProofResponse {
  output: Uint8Array;
}

function createBaseDataPeerListAnnounce(): DataPeerListAnnounce {
  return { peerList: [] };
}

export const DataPeerListAnnounce: MessageFns<DataPeerListAnnounce> = {
  encode(message: DataPeerListAnnounce, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.peerList) {
      DataPeer.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataPeerListAnnounce {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataPeerListAnnounce();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerList.push(DataPeer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataPeerListAnnounce {
    return {
      peerList: globalThis.Array.isArray(object?.peerList) ? object.peerList.map((e: any) => DataPeer.fromJSON(e)) : [],
    };
  },

  toJSON(message: DataPeerListAnnounce): unknown {
    const obj: any = {};
    if (message.peerList?.length) {
      obj.peerList = message.peerList.map((e) => DataPeer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataPeerListAnnounce>, I>>(base?: I): DataPeerListAnnounce {
    return DataPeerListAnnounce.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataPeerListAnnounce>, I>>(object: I): DataPeerListAnnounce {
    const message = createBaseDataPeerListAnnounce();
    message.peerList = object.peerList?.map((e) => DataPeer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDataPeer(): DataPeer {
  return {
    peerId: new Uint8Array(0),
    multiaddr: "",
    maxFrame: Long.UZERO,
    timestamp: Long.ZERO,
    version: new Uint8Array(0),
    signature: new Uint8Array(0),
    publicKey: new Uint8Array(0),
    totalDistance: new Uint8Array(0),
  };
}

export const DataPeer: MessageFns<DataPeer> = {
  encode(message: DataPeer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerId.length !== 0) {
      writer.uint32(10).bytes(message.peerId);
    }
    if (message.multiaddr !== "") {
      writer.uint32(18).string(message.multiaddr);
    }
    if (!message.maxFrame.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.maxFrame.toString());
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.timestamp.toString());
    }
    if (message.version.length !== 0) {
      writer.uint32(42).bytes(message.version);
    }
    if (message.signature.length !== 0) {
      writer.uint32(50).bytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(58).bytes(message.publicKey);
    }
    if (message.totalDistance.length !== 0) {
      writer.uint32(66).bytes(message.totalDistance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataPeer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataPeer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.multiaddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxFrame = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.version = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.totalDistance = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataPeer {
    return {
      peerId: isSet(object.peerId) ? bytesFromBase64(object.peerId) : new Uint8Array(0),
      multiaddr: isSet(object.multiaddr) ? globalThis.String(object.multiaddr) : "",
      maxFrame: isSet(object.maxFrame) ? Long.fromValue(object.maxFrame) : Long.UZERO,
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      version: isSet(object.version) ? bytesFromBase64(object.version) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      totalDistance: isSet(object.totalDistance) ? bytesFromBase64(object.totalDistance) : new Uint8Array(0),
    };
  },

  toJSON(message: DataPeer): unknown {
    const obj: any = {};
    if (message.peerId.length !== 0) {
      obj.peerId = base64FromBytes(message.peerId);
    }
    if (message.multiaddr !== "") {
      obj.multiaddr = message.multiaddr;
    }
    if (!message.maxFrame.equals(Long.UZERO)) {
      obj.maxFrame = (message.maxFrame || Long.UZERO).toString();
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (message.version.length !== 0) {
      obj.version = base64FromBytes(message.version);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.totalDistance.length !== 0) {
      obj.totalDistance = base64FromBytes(message.totalDistance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataPeer>, I>>(base?: I): DataPeer {
    return DataPeer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataPeer>, I>>(object: I): DataPeer {
    const message = createBaseDataPeer();
    message.peerId = object.peerId ?? new Uint8Array(0);
    message.multiaddr = object.multiaddr ?? "";
    message.maxFrame = (object.maxFrame !== undefined && object.maxFrame !== null)
      ? Long.fromValue(object.maxFrame)
      : Long.UZERO;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.version = object.version ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.totalDistance = object.totalDistance ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDataCompressedSync(): DataCompressedSync {
  return { fromFrameNumber: Long.UZERO, toFrameNumber: Long.UZERO, truncatedClockFrames: [], proofs: [], segments: [] };
}

export const DataCompressedSync: MessageFns<DataCompressedSync> = {
  encode(message: DataCompressedSync, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.fromFrameNumber.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.fromFrameNumber.toString());
    }
    if (!message.toFrameNumber.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.toFrameNumber.toString());
    }
    for (const v of message.truncatedClockFrames) {
      ClockFrame.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.proofs) {
      InclusionProofsMap.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.segments) {
      InclusionSegmentsMap.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataCompressedSync {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataCompressedSync();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromFrameNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toFrameNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.truncatedClockFrames.push(ClockFrame.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.proofs.push(InclusionProofsMap.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.segments.push(InclusionSegmentsMap.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataCompressedSync {
    return {
      fromFrameNumber: isSet(object.fromFrameNumber) ? Long.fromValue(object.fromFrameNumber) : Long.UZERO,
      toFrameNumber: isSet(object.toFrameNumber) ? Long.fromValue(object.toFrameNumber) : Long.UZERO,
      truncatedClockFrames: globalThis.Array.isArray(object?.truncatedClockFrames)
        ? object.truncatedClockFrames.map((e: any) => ClockFrame.fromJSON(e))
        : [],
      proofs: globalThis.Array.isArray(object?.proofs)
        ? object.proofs.map((e: any) => InclusionProofsMap.fromJSON(e))
        : [],
      segments: globalThis.Array.isArray(object?.segments)
        ? object.segments.map((e: any) => InclusionSegmentsMap.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DataCompressedSync): unknown {
    const obj: any = {};
    if (!message.fromFrameNumber.equals(Long.UZERO)) {
      obj.fromFrameNumber = (message.fromFrameNumber || Long.UZERO).toString();
    }
    if (!message.toFrameNumber.equals(Long.UZERO)) {
      obj.toFrameNumber = (message.toFrameNumber || Long.UZERO).toString();
    }
    if (message.truncatedClockFrames?.length) {
      obj.truncatedClockFrames = message.truncatedClockFrames.map((e) => ClockFrame.toJSON(e));
    }
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => InclusionProofsMap.toJSON(e));
    }
    if (message.segments?.length) {
      obj.segments = message.segments.map((e) => InclusionSegmentsMap.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataCompressedSync>, I>>(base?: I): DataCompressedSync {
    return DataCompressedSync.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataCompressedSync>, I>>(object: I): DataCompressedSync {
    const message = createBaseDataCompressedSync();
    message.fromFrameNumber = (object.fromFrameNumber !== undefined && object.fromFrameNumber !== null)
      ? Long.fromValue(object.fromFrameNumber)
      : Long.UZERO;
    message.toFrameNumber = (object.toFrameNumber !== undefined && object.toFrameNumber !== null)
      ? Long.fromValue(object.toFrameNumber)
      : Long.UZERO;
    message.truncatedClockFrames = object.truncatedClockFrames?.map((e) => ClockFrame.fromPartial(e)) || [];
    message.proofs = object.proofs?.map((e) => InclusionProofsMap.fromPartial(e)) || [];
    message.segments = object.segments?.map((e) => InclusionSegmentsMap.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSyncRequestAuthentication(): SyncRequestAuthentication {
  return { peerId: new Uint8Array(0), challenge: new Uint8Array(0), response: undefined };
}

export const SyncRequestAuthentication: MessageFns<SyncRequestAuthentication> = {
  encode(message: SyncRequestAuthentication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerId.length !== 0) {
      writer.uint32(10).bytes(message.peerId);
    }
    if (message.challenge.length !== 0) {
      writer.uint32(18).bytes(message.challenge);
    }
    if (message.response !== undefined) {
      Ed448Signature.encode(message.response, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncRequestAuthentication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRequestAuthentication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.response = Ed448Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncRequestAuthentication {
    return {
      peerId: isSet(object.peerId) ? bytesFromBase64(object.peerId) : new Uint8Array(0),
      challenge: isSet(object.challenge) ? bytesFromBase64(object.challenge) : new Uint8Array(0),
      response: isSet(object.response) ? Ed448Signature.fromJSON(object.response) : undefined,
    };
  },

  toJSON(message: SyncRequestAuthentication): unknown {
    const obj: any = {};
    if (message.peerId.length !== 0) {
      obj.peerId = base64FromBytes(message.peerId);
    }
    if (message.challenge.length !== 0) {
      obj.challenge = base64FromBytes(message.challenge);
    }
    if (message.response !== undefined) {
      obj.response = Ed448Signature.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncRequestAuthentication>, I>>(base?: I): SyncRequestAuthentication {
    return SyncRequestAuthentication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncRequestAuthentication>, I>>(object: I): SyncRequestAuthentication {
    const message = createBaseSyncRequestAuthentication();
    message.peerId = object.peerId ?? new Uint8Array(0);
    message.challenge = object.challenge ?? new Uint8Array(0);
    message.response = (object.response !== undefined && object.response !== null)
      ? Ed448Signature.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseDataCompressedSyncRequestMessage(): DataCompressedSyncRequestMessage {
  return { preflight: undefined, request: undefined, authentication: undefined };
}

export const DataCompressedSyncRequestMessage: MessageFns<DataCompressedSyncRequestMessage> = {
  encode(message: DataCompressedSyncRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preflight !== undefined) {
      ClockFramesPreflight.encode(message.preflight, writer.uint32(10).fork()).join();
    }
    if (message.request !== undefined) {
      ClockFramesRequest.encode(message.request, writer.uint32(18).fork()).join();
    }
    if (message.authentication !== undefined) {
      SyncRequestAuthentication.encode(message.authentication, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataCompressedSyncRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataCompressedSyncRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preflight = ClockFramesPreflight.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.request = ClockFramesRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authentication = SyncRequestAuthentication.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataCompressedSyncRequestMessage {
    return {
      preflight: isSet(object.preflight) ? ClockFramesPreflight.fromJSON(object.preflight) : undefined,
      request: isSet(object.request) ? ClockFramesRequest.fromJSON(object.request) : undefined,
      authentication: isSet(object.authentication)
        ? SyncRequestAuthentication.fromJSON(object.authentication)
        : undefined,
    };
  },

  toJSON(message: DataCompressedSyncRequestMessage): unknown {
    const obj: any = {};
    if (message.preflight !== undefined) {
      obj.preflight = ClockFramesPreflight.toJSON(message.preflight);
    }
    if (message.request !== undefined) {
      obj.request = ClockFramesRequest.toJSON(message.request);
    }
    if (message.authentication !== undefined) {
      obj.authentication = SyncRequestAuthentication.toJSON(message.authentication);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataCompressedSyncRequestMessage>, I>>(
    base?: I,
  ): DataCompressedSyncRequestMessage {
    return DataCompressedSyncRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataCompressedSyncRequestMessage>, I>>(
    object: I,
  ): DataCompressedSyncRequestMessage {
    const message = createBaseDataCompressedSyncRequestMessage();
    message.preflight = (object.preflight !== undefined && object.preflight !== null)
      ? ClockFramesPreflight.fromPartial(object.preflight)
      : undefined;
    message.request = (object.request !== undefined && object.request !== null)
      ? ClockFramesRequest.fromPartial(object.request)
      : undefined;
    message.authentication = (object.authentication !== undefined && object.authentication !== null)
      ? SyncRequestAuthentication.fromPartial(object.authentication)
      : undefined;
    return message;
  },
};

function createBaseDataCompressedSyncResponseMessage(): DataCompressedSyncResponseMessage {
  return { preflight: undefined, response: undefined };
}

export const DataCompressedSyncResponseMessage: MessageFns<DataCompressedSyncResponseMessage> = {
  encode(message: DataCompressedSyncResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preflight !== undefined) {
      ClockFramesPreflight.encode(message.preflight, writer.uint32(10).fork()).join();
    }
    if (message.response !== undefined) {
      DataCompressedSync.encode(message.response, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataCompressedSyncResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataCompressedSyncResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preflight = ClockFramesPreflight.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.response = DataCompressedSync.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataCompressedSyncResponseMessage {
    return {
      preflight: isSet(object.preflight) ? ClockFramesPreflight.fromJSON(object.preflight) : undefined,
      response: isSet(object.response) ? DataCompressedSync.fromJSON(object.response) : undefined,
    };
  },

  toJSON(message: DataCompressedSyncResponseMessage): unknown {
    const obj: any = {};
    if (message.preflight !== undefined) {
      obj.preflight = ClockFramesPreflight.toJSON(message.preflight);
    }
    if (message.response !== undefined) {
      obj.response = DataCompressedSync.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataCompressedSyncResponseMessage>, I>>(
    base?: I,
  ): DataCompressedSyncResponseMessage {
    return DataCompressedSyncResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataCompressedSyncResponseMessage>, I>>(
    object: I,
  ): DataCompressedSyncResponseMessage {
    const message = createBaseDataCompressedSyncResponseMessage();
    message.preflight = (object.preflight !== undefined && object.preflight !== null)
      ? ClockFramesPreflight.fromPartial(object.preflight)
      : undefined;
    message.response = (object.response !== undefined && object.response !== null)
      ? DataCompressedSync.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseInclusionProofsMap(): InclusionProofsMap {
  return { frameCommit: new Uint8Array(0), proof: new Uint8Array(0), commitments: [] };
}

export const InclusionProofsMap: MessageFns<InclusionProofsMap> = {
  encode(message: InclusionProofsMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frameCommit.length !== 0) {
      writer.uint32(10).bytes(message.frameCommit);
    }
    if (message.proof.length !== 0) {
      writer.uint32(18).bytes(message.proof);
    }
    for (const v of message.commitments) {
      InclusionCommitmentsMap.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InclusionProofsMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInclusionProofsMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.frameCommit = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proof = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commitments.push(InclusionCommitmentsMap.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InclusionProofsMap {
    return {
      frameCommit: isSet(object.frameCommit) ? bytesFromBase64(object.frameCommit) : new Uint8Array(0),
      proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(0),
      commitments: globalThis.Array.isArray(object?.commitments)
        ? object.commitments.map((e: any) => InclusionCommitmentsMap.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InclusionProofsMap): unknown {
    const obj: any = {};
    if (message.frameCommit.length !== 0) {
      obj.frameCommit = base64FromBytes(message.frameCommit);
    }
    if (message.proof.length !== 0) {
      obj.proof = base64FromBytes(message.proof);
    }
    if (message.commitments?.length) {
      obj.commitments = message.commitments.map((e) => InclusionCommitmentsMap.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InclusionProofsMap>, I>>(base?: I): InclusionProofsMap {
    return InclusionProofsMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InclusionProofsMap>, I>>(object: I): InclusionProofsMap {
    const message = createBaseInclusionProofsMap();
    message.frameCommit = object.frameCommit ?? new Uint8Array(0);
    message.proof = object.proof ?? new Uint8Array(0);
    message.commitments = object.commitments?.map((e) => InclusionCommitmentsMap.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInclusionSegmentsMap(): InclusionSegmentsMap {
  return { hash: new Uint8Array(0), data: new Uint8Array(0) };
}

export const InclusionSegmentsMap: MessageFns<InclusionSegmentsMap> = {
  encode(message: InclusionSegmentsMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InclusionSegmentsMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInclusionSegmentsMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InclusionSegmentsMap {
    return {
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: InclusionSegmentsMap): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InclusionSegmentsMap>, I>>(base?: I): InclusionSegmentsMap {
    return InclusionSegmentsMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InclusionSegmentsMap>, I>>(object: I): InclusionSegmentsMap {
    const message = createBaseInclusionSegmentsMap();
    message.hash = object.hash ?? new Uint8Array(0);
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInclusionCommitmentsMap(): InclusionCommitmentsMap {
  return { commitment: new Uint8Array(0), typeUrl: "", segmentHashes: [] };
}

export const InclusionCommitmentsMap: MessageFns<InclusionCommitmentsMap> = {
  encode(message: InclusionCommitmentsMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commitment.length !== 0) {
      writer.uint32(10).bytes(message.commitment);
    }
    if (message.typeUrl !== "") {
      writer.uint32(18).string(message.typeUrl);
    }
    for (const v of message.segmentHashes) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InclusionCommitmentsMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInclusionCommitmentsMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commitment = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typeUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.segmentHashes.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InclusionCommitmentsMap {
    return {
      commitment: isSet(object.commitment) ? bytesFromBase64(object.commitment) : new Uint8Array(0),
      typeUrl: isSet(object.typeUrl) ? globalThis.String(object.typeUrl) : "",
      segmentHashes: globalThis.Array.isArray(object?.segmentHashes)
        ? object.segmentHashes.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: InclusionCommitmentsMap): unknown {
    const obj: any = {};
    if (message.commitment.length !== 0) {
      obj.commitment = base64FromBytes(message.commitment);
    }
    if (message.typeUrl !== "") {
      obj.typeUrl = message.typeUrl;
    }
    if (message.segmentHashes?.length) {
      obj.segmentHashes = message.segmentHashes.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InclusionCommitmentsMap>, I>>(base?: I): InclusionCommitmentsMap {
    return InclusionCommitmentsMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InclusionCommitmentsMap>, I>>(object: I): InclusionCommitmentsMap {
    const message = createBaseInclusionCommitmentsMap();
    message.commitment = object.commitment ?? new Uint8Array(0);
    message.typeUrl = object.typeUrl ?? "";
    message.segmentHashes = object.segmentHashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDataFrameRequest(): GetDataFrameRequest {
  return { frameNumber: Long.UZERO };
}

export const GetDataFrameRequest: MessageFns<GetDataFrameRequest> = {
  encode(message: GetDataFrameRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.frameNumber.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.frameNumber.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDataFrameRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDataFrameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.frameNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDataFrameRequest {
    return { frameNumber: isSet(object.frameNumber) ? Long.fromValue(object.frameNumber) : Long.UZERO };
  },

  toJSON(message: GetDataFrameRequest): unknown {
    const obj: any = {};
    if (!message.frameNumber.equals(Long.UZERO)) {
      obj.frameNumber = (message.frameNumber || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDataFrameRequest>, I>>(base?: I): GetDataFrameRequest {
    return GetDataFrameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDataFrameRequest>, I>>(object: I): GetDataFrameRequest {
    const message = createBaseGetDataFrameRequest();
    message.frameNumber = (object.frameNumber !== undefined && object.frameNumber !== null)
      ? Long.fromValue(object.frameNumber)
      : Long.UZERO;
    return message;
  },
};

function createBaseDataFrameResponse(): DataFrameResponse {
  return { clockFrame: undefined, proof: new Uint8Array(0) };
}

export const DataFrameResponse: MessageFns<DataFrameResponse> = {
  encode(message: DataFrameResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clockFrame !== undefined) {
      ClockFrame.encode(message.clockFrame, writer.uint32(10).fork()).join();
    }
    if (message.proof.length !== 0) {
      writer.uint32(18).bytes(message.proof);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataFrameResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataFrameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clockFrame = ClockFrame.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proof = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataFrameResponse {
    return {
      clockFrame: isSet(object.clockFrame) ? ClockFrame.fromJSON(object.clockFrame) : undefined,
      proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(0),
    };
  },

  toJSON(message: DataFrameResponse): unknown {
    const obj: any = {};
    if (message.clockFrame !== undefined) {
      obj.clockFrame = ClockFrame.toJSON(message.clockFrame);
    }
    if (message.proof.length !== 0) {
      obj.proof = base64FromBytes(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataFrameResponse>, I>>(base?: I): DataFrameResponse {
    return DataFrameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataFrameResponse>, I>>(object: I): DataFrameResponse {
    const message = createBaseDataFrameResponse();
    message.clockFrame = (object.clockFrame !== undefined && object.clockFrame !== null)
      ? ClockFrame.fromPartial(object.clockFrame)
      : undefined;
    message.proof = object.proof ?? new Uint8Array(0);
    return message;
  },
};

function createBasePreMidnightMintResponse(): PreMidnightMintResponse {
  return { address: new Uint8Array(0), increment: 0 };
}

export const PreMidnightMintResponse: MessageFns<PreMidnightMintResponse> = {
  encode(message: PreMidnightMintResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.increment !== 0) {
      writer.uint32(16).uint32(message.increment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreMidnightMintResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreMidnightMintResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.increment = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreMidnightMintResponse {
    return {
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
      increment: isSet(object.increment) ? globalThis.Number(object.increment) : 0,
    };
  },

  toJSON(message: PreMidnightMintResponse): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.increment !== 0) {
      obj.increment = Math.round(message.increment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreMidnightMintResponse>, I>>(base?: I): PreMidnightMintResponse {
    return PreMidnightMintResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreMidnightMintResponse>, I>>(object: I): PreMidnightMintResponse {
    const message = createBasePreMidnightMintResponse();
    message.address = object.address ?? new Uint8Array(0);
    message.increment = object.increment ?? 0;
    return message;
  },
};

function createBasePreMidnightMintStatusRequest(): PreMidnightMintStatusRequest {
  return { owner: new Uint8Array(0) };
}

export const PreMidnightMintStatusRequest: MessageFns<PreMidnightMintStatusRequest> = {
  encode(message: PreMidnightMintStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner.length !== 0) {
      writer.uint32(10).bytes(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreMidnightMintStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreMidnightMintStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreMidnightMintStatusRequest {
    return { owner: isSet(object.owner) ? bytesFromBase64(object.owner) : new Uint8Array(0) };
  },

  toJSON(message: PreMidnightMintStatusRequest): unknown {
    const obj: any = {};
    if (message.owner.length !== 0) {
      obj.owner = base64FromBytes(message.owner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreMidnightMintStatusRequest>, I>>(base?: I): PreMidnightMintStatusRequest {
    return PreMidnightMintStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreMidnightMintStatusRequest>, I>>(object: I): PreMidnightMintStatusRequest {
    const message = createBasePreMidnightMintStatusRequest();
    message.owner = object.owner ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFrameRebroadcast(): FrameRebroadcast {
  return { from: Long.UZERO, to: Long.UZERO, clockFrames: [], random: new Uint8Array(0) };
}

export const FrameRebroadcast: MessageFns<FrameRebroadcast> = {
  encode(message: FrameRebroadcast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.from.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.from.toString());
    }
    if (!message.to.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.to.toString());
    }
    for (const v of message.clockFrames) {
      ClockFrame.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.random.length !== 0) {
      writer.uint32(34).bytes(message.random);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FrameRebroadcast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrameRebroadcast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.from = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.to = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clockFrames.push(ClockFrame.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.random = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FrameRebroadcast {
    return {
      from: isSet(object.from) ? Long.fromValue(object.from) : Long.UZERO,
      to: isSet(object.to) ? Long.fromValue(object.to) : Long.UZERO,
      clockFrames: globalThis.Array.isArray(object?.clockFrames)
        ? object.clockFrames.map((e: any) => ClockFrame.fromJSON(e))
        : [],
      random: isSet(object.random) ? bytesFromBase64(object.random) : new Uint8Array(0),
    };
  },

  toJSON(message: FrameRebroadcast): unknown {
    const obj: any = {};
    if (!message.from.equals(Long.UZERO)) {
      obj.from = (message.from || Long.UZERO).toString();
    }
    if (!message.to.equals(Long.UZERO)) {
      obj.to = (message.to || Long.UZERO).toString();
    }
    if (message.clockFrames?.length) {
      obj.clockFrames = message.clockFrames.map((e) => ClockFrame.toJSON(e));
    }
    if (message.random.length !== 0) {
      obj.random = base64FromBytes(message.random);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FrameRebroadcast>, I>>(base?: I): FrameRebroadcast {
    return FrameRebroadcast.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FrameRebroadcast>, I>>(object: I): FrameRebroadcast {
    const message = createBaseFrameRebroadcast();
    message.from = (object.from !== undefined && object.from !== null) ? Long.fromValue(object.from) : Long.UZERO;
    message.to = (object.to !== undefined && object.to !== null) ? Long.fromValue(object.to) : Long.UZERO;
    message.clockFrames = object.clockFrames?.map((e) => ClockFrame.fromPartial(e)) || [];
    message.random = object.random ?? new Uint8Array(0);
    return message;
  },
};

function createBaseChallengeProofRequest(): ChallengeProofRequest {
  return { peerId: new Uint8Array(0), clockFrame: undefined };
}

export const ChallengeProofRequest: MessageFns<ChallengeProofRequest> = {
  encode(message: ChallengeProofRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerId.length !== 0) {
      writer.uint32(10).bytes(message.peerId);
    }
    if (message.clockFrame !== undefined) {
      ClockFrame.encode(message.clockFrame, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChallengeProofRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeProofRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clockFrame = ClockFrame.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChallengeProofRequest {
    return {
      peerId: isSet(object.peerId) ? bytesFromBase64(object.peerId) : new Uint8Array(0),
      clockFrame: isSet(object.clockFrame) ? ClockFrame.fromJSON(object.clockFrame) : undefined,
    };
  },

  toJSON(message: ChallengeProofRequest): unknown {
    const obj: any = {};
    if (message.peerId.length !== 0) {
      obj.peerId = base64FromBytes(message.peerId);
    }
    if (message.clockFrame !== undefined) {
      obj.clockFrame = ClockFrame.toJSON(message.clockFrame);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChallengeProofRequest>, I>>(base?: I): ChallengeProofRequest {
    return ChallengeProofRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChallengeProofRequest>, I>>(object: I): ChallengeProofRequest {
    const message = createBaseChallengeProofRequest();
    message.peerId = object.peerId ?? new Uint8Array(0);
    message.clockFrame = (object.clockFrame !== undefined && object.clockFrame !== null)
      ? ClockFrame.fromPartial(object.clockFrame)
      : undefined;
    return message;
  },
};

function createBaseChallengeProofResponse(): ChallengeProofResponse {
  return { output: new Uint8Array(0) };
}

export const ChallengeProofResponse: MessageFns<ChallengeProofResponse> = {
  encode(message: ChallengeProofResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.output.length !== 0) {
      writer.uint32(10).bytes(message.output);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChallengeProofResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeProofResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.output = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChallengeProofResponse {
    return { output: isSet(object.output) ? bytesFromBase64(object.output) : new Uint8Array(0) };
  },

  toJSON(message: ChallengeProofResponse): unknown {
    const obj: any = {};
    if (message.output.length !== 0) {
      obj.output = base64FromBytes(message.output);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChallengeProofResponse>, I>>(base?: I): ChallengeProofResponse {
    return ChallengeProofResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChallengeProofResponse>, I>>(object: I): ChallengeProofResponse {
    const message = createBaseChallengeProofResponse();
    message.output = object.output ?? new Uint8Array(0);
    return message;
  },
};

export interface DataService {
  GetCompressedSyncFrames(request: ClockFramesRequest): Observable<DataCompressedSync>;
  NegotiateCompressedSyncFrames(
    request: Observable<DataCompressedSyncRequestMessage>,
  ): Observable<DataCompressedSyncResponseMessage>;
  GetPublicChannel(request: Observable<P2PChannelEnvelope>): Observable<P2PChannelEnvelope>;
  GetDataFrame(request: GetDataFrameRequest): Promise<DataFrameResponse>;
  HandlePreMidnightMint(request: MintCoinRequest): Promise<PreMidnightMintResponse>;
  GetPreMidnightMintStatus(request: PreMidnightMintStatusRequest): Promise<PreMidnightMintResponse>;
}

export const DataServiceServiceName = "quilibrium.node.data.pb.DataService";
export class DataServiceClientImpl implements DataService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || DataServiceServiceName;
    this.rpc = rpc;
    this.GetCompressedSyncFrames = this.GetCompressedSyncFrames.bind(this);
    this.NegotiateCompressedSyncFrames = this.NegotiateCompressedSyncFrames.bind(this);
    this.GetPublicChannel = this.GetPublicChannel.bind(this);
    this.GetDataFrame = this.GetDataFrame.bind(this);
    this.HandlePreMidnightMint = this.HandlePreMidnightMint.bind(this);
    this.GetPreMidnightMintStatus = this.GetPreMidnightMintStatus.bind(this);
  }
  GetCompressedSyncFrames(request: ClockFramesRequest): Observable<DataCompressedSync> {
    const data = ClockFramesRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "GetCompressedSyncFrames", data);
    return result.pipe(map((data) => DataCompressedSync.decode(new BinaryReader(data))));
  }

  NegotiateCompressedSyncFrames(
    request: Observable<DataCompressedSyncRequestMessage>,
  ): Observable<DataCompressedSyncResponseMessage> {
    const data = request.pipe(map((request) => DataCompressedSyncRequestMessage.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "NegotiateCompressedSyncFrames", data);
    return result.pipe(map((data) => DataCompressedSyncResponseMessage.decode(new BinaryReader(data))));
  }

  GetPublicChannel(request: Observable<P2PChannelEnvelope>): Observable<P2PChannelEnvelope> {
    const data = request.pipe(map((request) => P2PChannelEnvelope.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "GetPublicChannel", data);
    return result.pipe(map((data) => P2PChannelEnvelope.decode(new BinaryReader(data))));
  }

  GetDataFrame(request: GetDataFrameRequest): Promise<DataFrameResponse> {
    const data = GetDataFrameRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDataFrame", data);
    return promise.then((data) => DataFrameResponse.decode(new BinaryReader(data)));
  }

  HandlePreMidnightMint(request: MintCoinRequest): Promise<PreMidnightMintResponse> {
    const data = MintCoinRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "HandlePreMidnightMint", data);
    return promise.then((data) => PreMidnightMintResponse.decode(new BinaryReader(data)));
  }

  GetPreMidnightMintStatus(request: PreMidnightMintStatusRequest): Promise<PreMidnightMintResponse> {
    const data = PreMidnightMintStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreMidnightMintStatus", data);
    return promise.then((data) => PreMidnightMintResponse.decode(new BinaryReader(data)));
  }
}

export interface DataIPCService {
  CalculateChallengeProof(request: ChallengeProofRequest): Promise<ChallengeProofResponse>;
}

export const DataIPCServiceServiceName = "quilibrium.node.data.pb.DataIPCService";
export class DataIPCServiceClientImpl implements DataIPCService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || DataIPCServiceServiceName;
    this.rpc = rpc;
    this.CalculateChallengeProof = this.CalculateChallengeProof.bind(this);
  }
  CalculateChallengeProof(request: ChallengeProofRequest): Promise<ChallengeProofResponse> {
    const data = ChallengeProofRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CalculateChallengeProof", data);
    return promise.then((data) => ChallengeProofResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
