// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v3.20.3
// source: node.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { ClockFrame, ClockFramesRequest, ClockFramesResponse } from "./clock";
import { Ed448Signature } from "./keys";

export const protobufPackage = "quilibrium.node.node.pb";

export interface GetFramesRequest {
  filter: Uint8Array;
  fromFrameNumber: Long;
  toFrameNumber: Long;
  includeCandidates: boolean;
}

export interface GetFrameInfoRequest {
  filter: Uint8Array;
  frameNumber: Long;
  selector: Uint8Array;
}

export interface GetPeerInfoRequest {
}

export interface GetNodeInfoRequest {
}

export interface GetNetworkInfoRequest {
}

export interface FramesResponse {
  truncatedClockFrames: ClockFrame[];
}

export interface FrameInfoResponse {
  clockFrame: ClockFrame | undefined;
}

export interface PeerInfo {
  peerId: Uint8Array;
  multiaddrs: string[];
  maxFrame: Long;
  timestamp: Long;
  version: Uint8Array;
  signature: Uint8Array;
  publicKey: Uint8Array;
  totalDistance: Uint8Array;
}

export interface PeerInfoResponse {
  peerInfo: PeerInfo[];
  uncooperativePeerInfo: PeerInfo[];
}

export interface NetworkInfo {
  peerId: Uint8Array;
  multiaddrs: string[];
  peerScore: number;
}

export interface NodeInfoResponse {
  peerId: string;
  maxFrame: Long;
  peerScore: Long;
  version: Uint8Array;
}

export interface PutPeerInfoRequest {
  peerInfo: PeerInfo[];
  uncooperativePeerInfo: PeerInfo[];
}

export interface PutNodeInfoRequest {
  peerId: string;
  maxFrame: Long;
  peerScore: Long;
  signature: Uint8Array;
}

export interface PutResponse {
}

export interface NetworkInfoResponse {
  networkInfo: NetworkInfo[];
}

export interface GetTokenInfoRequest {
  /** optional, v2.0 only */
  address: Uint8Array;
}

export interface TokenInfoResponse {
  /**
   * Total active token supply, as a 256 bit integer representing maximum
   * divisble units. 1 QUIL = 8000000000 units, 50 QUIL would be represented by
   * 0x0000000000000000000000000000000000000000000000000000005D21DBA000
   */
  confirmedTokenSupply: Uint8Array;
  /** Total token supply, including unconfirmed frame data, as a 256 bit integer. */
  unconfirmedTokenSupply: Uint8Array;
  /**
   * The total number of tokens owned by the prover address associated with the
   * node.
   */
  ownedTokens: Uint8Array;
  /**
   * The total number of tokens owned by the prover address associated with the
   * node, including unconfirmed frame data.
   */
  unconfirmedOwnedTokens: Uint8Array;
}

export interface Capability {
  /**
   * A general protocol identifier as a uint32 – this is expected to rarely
   * iterate, and should be uniquely identifying both protocol and version.
   * Pragmatically speaking, this implies that the least significant byte
   * specifies version (which should iterate most minimally), and the three most
   * significant bytes should specify protocol. Recipients SHOULD ignore
   * messages with incompatible protocol identifiers, but also SHOULD warn on
   * identifiers with versions higher than the supported protocol. A large
   * number of unsupported protocol messages may indicate spam/some other
   * attack, whereas a large number of unsupported protocol versions may
   * indicate an out of date client, respective to which side is the maximum of
   * the version number.
   */
  protocolIdentifier: number;
  /**
   * An optional bundle of information specific to the capability – used for
   * extensibility in negotiating variations of a protocol – e.g. Triple-Ratchet
   * but only for certain curve types.
   */
  additionalMetadata: Uint8Array;
}

export interface SelfTestReport {
  /** The number of reported accessible cores */
  cores: number;
  /** The total available memory */
  memory: Uint8Array;
  /** The total available storage */
  storage: Uint8Array;
  /** The list of supported capabilities */
  capabilities: Capability[];
  /** The highest master frame the node has */
  masterHeadFrame: Long;
  /** The bit slice declaring prover range */
  proverRange: Uint8Array;
}

export interface ValidationMessage {
  validation: Uint8Array;
}

export interface SyncRequest {
  framesRequest: ClockFramesRequest | undefined;
}

export interface SyncResponse {
  framesResponse: ClockFramesResponse | undefined;
}

export interface GetPeerManifestsRequest {
}

export interface PeerManifest {
  peerId: Uint8Array;
  /** The number of reported accessible cores */
  cores: number;
  /** The total available memory */
  memory: Uint8Array;
  /** The total available storage */
  storage: Uint8Array;
  /** The list of supported capabilities */
  capabilities: Capability[];
  /** The highest master frame the node has */
  masterHeadFrame: Long;
  /** The last time seen tick */
  lastSeen: Long;
  /** The increment of the node */
  increment: number;
}

export interface AnnounceProverRequest {
  publicKeySignaturesEd448: Ed448Signature[];
  initialProof: MintCoinRequest | undefined;
}

export interface AnnounceProverJoin {
  filter: Uint8Array;
  frameNumber: Long;
  publicKeySignatureEd448: Ed448Signature | undefined;
}

export interface AnnounceProverLeave {
  filter: Uint8Array;
  frameNumber: Long;
  publicKeySignatureEd448: Ed448Signature | undefined;
}

export interface AnnounceProverPause {
  filter: Uint8Array;
  frameNumber: Long;
  publicKeySignatureEd448: Ed448Signature | undefined;
}

export interface AnnounceProverResume {
  filter: Uint8Array;
  frameNumber: Long;
  publicKeySignatureEd448: Ed448Signature | undefined;
}

export interface OriginatedAccountRef {
  address: Uint8Array;
}

export interface ImplicitAccount {
  implicitType: number;
  address: Uint8Array;
  domain: Uint8Array;
}

export interface AccountRef {
  originatedAccount?: OriginatedAccountRef | undefined;
  implicitAccount?: ImplicitAccount | undefined;
}

export interface AccountAllowanceRef {
  address: Uint8Array;
}

export interface CoinAllowanceRef {
  address: Uint8Array;
}

export interface Coin {
  amount: Uint8Array;
  intersection: Uint8Array;
  owner: AccountRef | undefined;
}

export interface TokenRequest {
  transfer?: TransferCoinRequest | undefined;
  split?: SplitCoinRequest | undefined;
  merge?: MergeCoinRequest | undefined;
  mint?: MintCoinRequest | undefined;
  announce?: AnnounceProverRequest | undefined;
}

export interface TokenRequests {
  requests: TokenRequest[];
}

export interface PreCoinProof {
  amount: Uint8Array;
  index: number;
  indexProof: Uint8Array;
  commitment: Uint8Array;
  proof: Uint8Array;
  parallelism: number;
  difficulty: number;
  owner: AccountRef | undefined;
}

export interface TokenOutput {
  coin?: Coin | undefined;
  proof?: PreCoinProof | undefined;
  deletedCoin?: CoinRef | undefined;
  deletedProof?: PreCoinProof | undefined;
}

export interface TokenOutputs {
  outputs: TokenOutput[];
}

export interface CoinRef {
  address: Uint8Array;
}

export interface PendingTransactionRef {
  address: Uint8Array;
}

export interface KeyRef {
  address: Uint8Array;
}

export interface Signature {
  signatureType: number;
  signature: Uint8Array;
  key: KeyRef | undefined;
}

export interface PeerManifestsResponse {
  peerManifests: PeerManifest[];
}

export interface AcceptPendingTransactionRequest {
  pendingTransaction: PendingTransactionRef | undefined;
  signature: Signature | undefined;
}

export interface AllowAccountRequest {
  ofAccount: AccountRef | undefined;
  permittedAccount: AccountRef | undefined;
  permittedOperations: string[];
  allowance: AccountAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface AllowCoinRequest {
  ofCoin: CoinRef | undefined;
  permittedAccount: AccountRef | undefined;
  permittedOperations: string[];
  accountAllowance: AccountAllowanceRef | undefined;
  coinAllowance: CoinAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface BalanceAccountRequest {
  account: AccountRef | undefined;
  allowance: AccountAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface CoinsAccountRequest {
  account: AccountRef | undefined;
  allowance: AccountAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface PendingTransactionsAccountRequest {
  account: AccountRef | undefined;
  allowance: AccountAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface IntersectCoinRequest {
  addresses: Uint8Array[];
  accountAllowance: AccountAllowanceRef | undefined;
  coinAllowance: CoinAllowanceRef | undefined;
  ofCoin: CoinRef | undefined;
}

export interface MergeCoinRequest {
  coins: CoinRef[];
  accountAllowance: AccountAllowanceRef | undefined;
  coinAllowances: CoinAllowanceRef[];
  signature: Ed448Signature | undefined;
}

export interface MintCoinRequest {
  proofs: Uint8Array[];
  allowance: AccountAllowanceRef | undefined;
  signature: Ed448Signature | undefined;
}

export interface MutualReceiveCoinRequest {
  toAccount: AccountRef | undefined;
  allowance: AccountAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface MutualTransferCoinRequest {
  rendezvous: Uint8Array;
  ofCoin: CoinRef | undefined;
  accountAllowance: AccountAllowanceRef | undefined;
  coinAllowance: CoinAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface RevokeAccountRequest {
  ofAccount: AccountRef | undefined;
  revokedAllowance: AccountAllowanceRef | undefined;
  allowance: AccountAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface RevokeCoinRequest {
  ofCoin: CoinRef | undefined;
  revokedAllowance: CoinAllowanceRef | undefined;
  accountAllowance: AccountAllowanceRef | undefined;
  coinAllowance: CoinAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface SplitCoinRequest {
  ofCoin: CoinRef | undefined;
  amounts: Uint8Array[];
  accountAllowance: AccountAllowanceRef | undefined;
  coinAllowance: CoinAllowanceRef | undefined;
  signature: Ed448Signature | undefined;
}

export interface TransferCoinRequest {
  toAccount: AccountRef | undefined;
  refundAccount: AccountRef | undefined;
  ofCoin: CoinRef | undefined;
  expiry: Long;
  accountAllowance: AccountAllowanceRef | undefined;
  coinAllowance: CoinAllowanceRef | undefined;
  signature: Ed448Signature | undefined;
}

export interface ApprovePendingTransactionRequest {
  pendingTransaction: PendingTransactionRef | undefined;
  accountAllowance: AccountAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface RejectPendingTransactionRequest {
  pendingTransaction: PendingTransactionRef | undefined;
  accountAllowance: AccountAllowanceRef | undefined;
  signature: Signature | undefined;
}

export interface InlineKey {
  ref: Uint8Array;
  key: Uint8Array;
}

export interface KeyRing {
  keys: InlineKey[];
}

export interface Confirmation {
  messageId: Uint8Array;
  proof: Uint8Array;
}

export interface DeliveryData {
  sharedKey: InlineKey | undefined;
  confirmation: Confirmation | undefined;
}

export interface DeliveryMethod {
  deliveryType: number;
  address: Uint8Array;
}

export interface DecryptableAllowAccountRequest {
  request: AllowAccountRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableBalanceAccountRequest {
  request: BalanceAccountRequest | undefined;
  keyRing: KeyRing | undefined;
}

export interface DecryptableCoinsAccountRequest {
  request: CoinsAccountRequest | undefined;
  keyRing: KeyRing | undefined;
}

export interface DecryptableRevokeAccountRequest {
  request: RevokeAccountRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptablePendingTransactionsAccountRequest {
  request: PendingTransactionsAccountRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableAllowCoinRequest {
  request: AllowCoinRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableIntersectCoinRequest {
  request: IntersectCoinRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableMergeCoinRequest {
  request: MergeCoinRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableMintCoinRequest {
  request: MintCoinRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableMutualReceiveCoinRequest {
  request: MutualReceiveCoinRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableMutualTransferCoinRequest {
  request: MutualTransferCoinRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableRevokeCoinRequest {
  request: RevokeCoinRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableSplitCoinRequest {
  request: SplitCoinRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableTransferCoinRequest {
  request: TransferCoinRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableApprovePendingTransactionRequest {
  request: ApprovePendingTransactionRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface DecryptableRejectPendingTransactionRequest {
  request: RejectPendingTransactionRequest | undefined;
  keyRing: KeyRing | undefined;
  deliveryMethod: DeliveryMethod | undefined;
}

export interface CoinInfo {
  coin: CoinRef | undefined;
  balance: Uint8Array;
}

export interface PendingTransactionInfo {
  pendingTransaction: PendingTransactionRef | undefined;
  coin: CoinInfo | undefined;
  refundAccount: AccountRef | undefined;
}

export interface AllowAccountResponse {
  allowance: AccountAllowanceRef | undefined;
  deliveries: DeliveryData[];
}

export interface BalanceAccountResponse {
  balance: Uint8Array;
}

export interface CoinsAccountResponse {
  coins: CoinInfo[];
}

export interface PendingTransactionsAccountResponse {
  pendingTransactions: PendingTransactionInfo[];
}

export interface RevokeAccountResponse {
  deliveries: DeliveryData[];
}

export interface AllowCoinResponse {
  allowance: CoinAllowanceRef | undefined;
  deliveries: DeliveryData[];
}

export interface IntersectCoinResponse {
  intersects: boolean;
}

export interface MergeCoinResponse {
  coin: CoinRef | undefined;
  deliveries: DeliveryData[];
}

export interface MintCoinResponse {
  coins: CoinInfo[];
  deliveries: DeliveryData[];
}

export interface MutualReceiveCoinResponse {
  status: number;
  rendezvous: Uint8Array;
  coin: CoinRef | undefined;
  deliveries: DeliveryData[];
}

export interface MutualTransferCoinResponse {
  status: number;
  deliveries: DeliveryData[];
}

export interface RevokeCoinResponse {
  deliveries: DeliveryData[];
}

export interface SplitCoinResponse {
  coins: CoinRef[];
  deliveries: DeliveryData[];
}

export interface TransferCoinResponse {
  pendingTransaction: PendingTransactionRef | undefined;
  deliveries: DeliveryData[];
}

export interface ApprovePendingTransactionResponse {
  coin: CoinRef | undefined;
  deliveries: DeliveryData[];
}

export interface RejectPendingTransactionResponse {
  deliveries: DeliveryData[];
}

export interface SendMessageResponse {
}

export interface GetTokensByAccountRequest {
  address: Uint8Array;
}

export interface TokensByAccountResponse {
  coins: Coin[];
  frameNumbers: Long[];
  addresses: Uint8Array[];
}

export interface GetPreCoinProofsByAccountRequest {
  address: Uint8Array;
}

export interface PreCoinProofsByAccountResponse {
  proofs: PreCoinProof[];
  frameNumbers: Long[];
}

function createBaseGetFramesRequest(): GetFramesRequest {
  return {
    filter: new Uint8Array(0),
    fromFrameNumber: Long.UZERO,
    toFrameNumber: Long.UZERO,
    includeCandidates: false,
  };
}

export const GetFramesRequest: MessageFns<GetFramesRequest> = {
  encode(message: GetFramesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter.length !== 0) {
      writer.uint32(10).bytes(message.filter);
    }
    if (!message.fromFrameNumber.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.fromFrameNumber.toString());
    }
    if (!message.toFrameNumber.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.toFrameNumber.toString());
    }
    if (message.includeCandidates !== false) {
      writer.uint32(32).bool(message.includeCandidates);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFramesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFramesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromFrameNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toFrameNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includeCandidates = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFramesRequest {
    return {
      filter: isSet(object.filter) ? bytesFromBase64(object.filter) : new Uint8Array(0),
      fromFrameNumber: isSet(object.fromFrameNumber) ? Long.fromValue(object.fromFrameNumber) : Long.UZERO,
      toFrameNumber: isSet(object.toFrameNumber) ? Long.fromValue(object.toFrameNumber) : Long.UZERO,
      includeCandidates: isSet(object.includeCandidates) ? globalThis.Boolean(object.includeCandidates) : false,
    };
  },

  toJSON(message: GetFramesRequest): unknown {
    const obj: any = {};
    if (message.filter.length !== 0) {
      obj.filter = base64FromBytes(message.filter);
    }
    if (!message.fromFrameNumber.equals(Long.UZERO)) {
      obj.fromFrameNumber = (message.fromFrameNumber || Long.UZERO).toString();
    }
    if (!message.toFrameNumber.equals(Long.UZERO)) {
      obj.toFrameNumber = (message.toFrameNumber || Long.UZERO).toString();
    }
    if (message.includeCandidates !== false) {
      obj.includeCandidates = message.includeCandidates;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFramesRequest>, I>>(base?: I): GetFramesRequest {
    return GetFramesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFramesRequest>, I>>(object: I): GetFramesRequest {
    const message = createBaseGetFramesRequest();
    message.filter = object.filter ?? new Uint8Array(0);
    message.fromFrameNumber = (object.fromFrameNumber !== undefined && object.fromFrameNumber !== null)
      ? Long.fromValue(object.fromFrameNumber)
      : Long.UZERO;
    message.toFrameNumber = (object.toFrameNumber !== undefined && object.toFrameNumber !== null)
      ? Long.fromValue(object.toFrameNumber)
      : Long.UZERO;
    message.includeCandidates = object.includeCandidates ?? false;
    return message;
  },
};

function createBaseGetFrameInfoRequest(): GetFrameInfoRequest {
  return { filter: new Uint8Array(0), frameNumber: Long.UZERO, selector: new Uint8Array(0) };
}

export const GetFrameInfoRequest: MessageFns<GetFrameInfoRequest> = {
  encode(message: GetFrameInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter.length !== 0) {
      writer.uint32(10).bytes(message.filter);
    }
    if (!message.frameNumber.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.frameNumber.toString());
    }
    if (message.selector.length !== 0) {
      writer.uint32(26).bytes(message.selector);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFrameInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFrameInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.frameNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.selector = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFrameInfoRequest {
    return {
      filter: isSet(object.filter) ? bytesFromBase64(object.filter) : new Uint8Array(0),
      frameNumber: isSet(object.frameNumber) ? Long.fromValue(object.frameNumber) : Long.UZERO,
      selector: isSet(object.selector) ? bytesFromBase64(object.selector) : new Uint8Array(0),
    };
  },

  toJSON(message: GetFrameInfoRequest): unknown {
    const obj: any = {};
    if (message.filter.length !== 0) {
      obj.filter = base64FromBytes(message.filter);
    }
    if (!message.frameNumber.equals(Long.UZERO)) {
      obj.frameNumber = (message.frameNumber || Long.UZERO).toString();
    }
    if (message.selector.length !== 0) {
      obj.selector = base64FromBytes(message.selector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFrameInfoRequest>, I>>(base?: I): GetFrameInfoRequest {
    return GetFrameInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFrameInfoRequest>, I>>(object: I): GetFrameInfoRequest {
    const message = createBaseGetFrameInfoRequest();
    message.filter = object.filter ?? new Uint8Array(0);
    message.frameNumber = (object.frameNumber !== undefined && object.frameNumber !== null)
      ? Long.fromValue(object.frameNumber)
      : Long.UZERO;
    message.selector = object.selector ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetPeerInfoRequest(): GetPeerInfoRequest {
  return {};
}

export const GetPeerInfoRequest: MessageFns<GetPeerInfoRequest> = {
  encode(_: GetPeerInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPeerInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPeerInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetPeerInfoRequest {
    return {};
  },

  toJSON(_: GetPeerInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPeerInfoRequest>, I>>(base?: I): GetPeerInfoRequest {
    return GetPeerInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPeerInfoRequest>, I>>(_: I): GetPeerInfoRequest {
    const message = createBaseGetPeerInfoRequest();
    return message;
  },
};

function createBaseGetNodeInfoRequest(): GetNodeInfoRequest {
  return {};
}

export const GetNodeInfoRequest: MessageFns<GetNodeInfoRequest> = {
  encode(_: GetNodeInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetNodeInfoRequest {
    return {};
  },

  toJSON(_: GetNodeInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeInfoRequest>, I>>(base?: I): GetNodeInfoRequest {
    return GetNodeInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeInfoRequest>, I>>(_: I): GetNodeInfoRequest {
    const message = createBaseGetNodeInfoRequest();
    return message;
  },
};

function createBaseGetNetworkInfoRequest(): GetNetworkInfoRequest {
  return {};
}

export const GetNetworkInfoRequest: MessageFns<GetNetworkInfoRequest> = {
  encode(_: GetNetworkInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetNetworkInfoRequest {
    return {};
  },

  toJSON(_: GetNetworkInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNetworkInfoRequest>, I>>(base?: I): GetNetworkInfoRequest {
    return GetNetworkInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNetworkInfoRequest>, I>>(_: I): GetNetworkInfoRequest {
    const message = createBaseGetNetworkInfoRequest();
    return message;
  },
};

function createBaseFramesResponse(): FramesResponse {
  return { truncatedClockFrames: [] };
}

export const FramesResponse: MessageFns<FramesResponse> = {
  encode(message: FramesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.truncatedClockFrames) {
      ClockFrame.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FramesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFramesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.truncatedClockFrames.push(ClockFrame.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FramesResponse {
    return {
      truncatedClockFrames: globalThis.Array.isArray(object?.truncatedClockFrames)
        ? object.truncatedClockFrames.map((e: any) => ClockFrame.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FramesResponse): unknown {
    const obj: any = {};
    if (message.truncatedClockFrames?.length) {
      obj.truncatedClockFrames = message.truncatedClockFrames.map((e) => ClockFrame.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FramesResponse>, I>>(base?: I): FramesResponse {
    return FramesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FramesResponse>, I>>(object: I): FramesResponse {
    const message = createBaseFramesResponse();
    message.truncatedClockFrames = object.truncatedClockFrames?.map((e) => ClockFrame.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFrameInfoResponse(): FrameInfoResponse {
  return { clockFrame: undefined };
}

export const FrameInfoResponse: MessageFns<FrameInfoResponse> = {
  encode(message: FrameInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clockFrame !== undefined) {
      ClockFrame.encode(message.clockFrame, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FrameInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrameInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clockFrame = ClockFrame.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FrameInfoResponse {
    return { clockFrame: isSet(object.clockFrame) ? ClockFrame.fromJSON(object.clockFrame) : undefined };
  },

  toJSON(message: FrameInfoResponse): unknown {
    const obj: any = {};
    if (message.clockFrame !== undefined) {
      obj.clockFrame = ClockFrame.toJSON(message.clockFrame);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FrameInfoResponse>, I>>(base?: I): FrameInfoResponse {
    return FrameInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FrameInfoResponse>, I>>(object: I): FrameInfoResponse {
    const message = createBaseFrameInfoResponse();
    message.clockFrame = (object.clockFrame !== undefined && object.clockFrame !== null)
      ? ClockFrame.fromPartial(object.clockFrame)
      : undefined;
    return message;
  },
};

function createBasePeerInfo(): PeerInfo {
  return {
    peerId: new Uint8Array(0),
    multiaddrs: [],
    maxFrame: Long.UZERO,
    timestamp: Long.ZERO,
    version: new Uint8Array(0),
    signature: new Uint8Array(0),
    publicKey: new Uint8Array(0),
    totalDistance: new Uint8Array(0),
  };
}

export const PeerInfo: MessageFns<PeerInfo> = {
  encode(message: PeerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerId.length !== 0) {
      writer.uint32(10).bytes(message.peerId);
    }
    for (const v of message.multiaddrs) {
      writer.uint32(18).string(v!);
    }
    if (!message.maxFrame.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.maxFrame.toString());
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.timestamp.toString());
    }
    if (message.version.length !== 0) {
      writer.uint32(42).bytes(message.version);
    }
    if (message.signature.length !== 0) {
      writer.uint32(50).bytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(58).bytes(message.publicKey);
    }
    if (message.totalDistance.length !== 0) {
      writer.uint32(66).bytes(message.totalDistance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.multiaddrs.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxFrame = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.version = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.totalDistance = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeerInfo {
    return {
      peerId: isSet(object.peerId) ? bytesFromBase64(object.peerId) : new Uint8Array(0),
      multiaddrs: globalThis.Array.isArray(object?.multiaddrs)
        ? object.multiaddrs.map((e: any) => globalThis.String(e))
        : [],
      maxFrame: isSet(object.maxFrame) ? Long.fromValue(object.maxFrame) : Long.UZERO,
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      version: isSet(object.version) ? bytesFromBase64(object.version) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      totalDistance: isSet(object.totalDistance) ? bytesFromBase64(object.totalDistance) : new Uint8Array(0),
    };
  },

  toJSON(message: PeerInfo): unknown {
    const obj: any = {};
    if (message.peerId.length !== 0) {
      obj.peerId = base64FromBytes(message.peerId);
    }
    if (message.multiaddrs?.length) {
      obj.multiaddrs = message.multiaddrs;
    }
    if (!message.maxFrame.equals(Long.UZERO)) {
      obj.maxFrame = (message.maxFrame || Long.UZERO).toString();
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (message.version.length !== 0) {
      obj.version = base64FromBytes(message.version);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.totalDistance.length !== 0) {
      obj.totalDistance = base64FromBytes(message.totalDistance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeerInfo>, I>>(base?: I): PeerInfo {
    return PeerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeerInfo>, I>>(object: I): PeerInfo {
    const message = createBasePeerInfo();
    message.peerId = object.peerId ?? new Uint8Array(0);
    message.multiaddrs = object.multiaddrs?.map((e) => e) || [];
    message.maxFrame = (object.maxFrame !== undefined && object.maxFrame !== null)
      ? Long.fromValue(object.maxFrame)
      : Long.UZERO;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.version = object.version ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.totalDistance = object.totalDistance ?? new Uint8Array(0);
    return message;
  },
};

function createBasePeerInfoResponse(): PeerInfoResponse {
  return { peerInfo: [], uncooperativePeerInfo: [] };
}

export const PeerInfoResponse: MessageFns<PeerInfoResponse> = {
  encode(message: PeerInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.peerInfo) {
      PeerInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.uncooperativePeerInfo) {
      PeerInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeerInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeerInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerInfo.push(PeerInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uncooperativePeerInfo.push(PeerInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeerInfoResponse {
    return {
      peerInfo: globalThis.Array.isArray(object?.peerInfo) ? object.peerInfo.map((e: any) => PeerInfo.fromJSON(e)) : [],
      uncooperativePeerInfo: globalThis.Array.isArray(object?.uncooperativePeerInfo)
        ? object.uncooperativePeerInfo.map((e: any) => PeerInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PeerInfoResponse): unknown {
    const obj: any = {};
    if (message.peerInfo?.length) {
      obj.peerInfo = message.peerInfo.map((e) => PeerInfo.toJSON(e));
    }
    if (message.uncooperativePeerInfo?.length) {
      obj.uncooperativePeerInfo = message.uncooperativePeerInfo.map((e) => PeerInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeerInfoResponse>, I>>(base?: I): PeerInfoResponse {
    return PeerInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeerInfoResponse>, I>>(object: I): PeerInfoResponse {
    const message = createBasePeerInfoResponse();
    message.peerInfo = object.peerInfo?.map((e) => PeerInfo.fromPartial(e)) || [];
    message.uncooperativePeerInfo = object.uncooperativePeerInfo?.map((e) => PeerInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNetworkInfo(): NetworkInfo {
  return { peerId: new Uint8Array(0), multiaddrs: [], peerScore: 0 };
}

export const NetworkInfo: MessageFns<NetworkInfo> = {
  encode(message: NetworkInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerId.length !== 0) {
      writer.uint32(10).bytes(message.peerId);
    }
    for (const v of message.multiaddrs) {
      writer.uint32(18).string(v!);
    }
    if (message.peerScore !== 0) {
      writer.uint32(25).double(message.peerScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.multiaddrs.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.peerScore = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkInfo {
    return {
      peerId: isSet(object.peerId) ? bytesFromBase64(object.peerId) : new Uint8Array(0),
      multiaddrs: globalThis.Array.isArray(object?.multiaddrs)
        ? object.multiaddrs.map((e: any) => globalThis.String(e))
        : [],
      peerScore: isSet(object.peerScore) ? globalThis.Number(object.peerScore) : 0,
    };
  },

  toJSON(message: NetworkInfo): unknown {
    const obj: any = {};
    if (message.peerId.length !== 0) {
      obj.peerId = base64FromBytes(message.peerId);
    }
    if (message.multiaddrs?.length) {
      obj.multiaddrs = message.multiaddrs;
    }
    if (message.peerScore !== 0) {
      obj.peerScore = message.peerScore;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetworkInfo>, I>>(base?: I): NetworkInfo {
    return NetworkInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetworkInfo>, I>>(object: I): NetworkInfo {
    const message = createBaseNetworkInfo();
    message.peerId = object.peerId ?? new Uint8Array(0);
    message.multiaddrs = object.multiaddrs?.map((e) => e) || [];
    message.peerScore = object.peerScore ?? 0;
    return message;
  },
};

function createBaseNodeInfoResponse(): NodeInfoResponse {
  return { peerId: "", maxFrame: Long.UZERO, peerScore: Long.UZERO, version: new Uint8Array(0) };
}

export const NodeInfoResponse: MessageFns<NodeInfoResponse> = {
  encode(message: NodeInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerId !== "") {
      writer.uint32(10).string(message.peerId);
    }
    if (!message.maxFrame.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.maxFrame.toString());
    }
    if (!message.peerScore.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.peerScore.toString());
    }
    if (message.version.length !== 0) {
      writer.uint32(34).bytes(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxFrame = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.peerScore = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeInfoResponse {
    return {
      peerId: isSet(object.peerId) ? globalThis.String(object.peerId) : "",
      maxFrame: isSet(object.maxFrame) ? Long.fromValue(object.maxFrame) : Long.UZERO,
      peerScore: isSet(object.peerScore) ? Long.fromValue(object.peerScore) : Long.UZERO,
      version: isSet(object.version) ? bytesFromBase64(object.version) : new Uint8Array(0),
    };
  },

  toJSON(message: NodeInfoResponse): unknown {
    const obj: any = {};
    if (message.peerId !== "") {
      obj.peerId = message.peerId;
    }
    if (!message.maxFrame.equals(Long.UZERO)) {
      obj.maxFrame = (message.maxFrame || Long.UZERO).toString();
    }
    if (!message.peerScore.equals(Long.UZERO)) {
      obj.peerScore = (message.peerScore || Long.UZERO).toString();
    }
    if (message.version.length !== 0) {
      obj.version = base64FromBytes(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeInfoResponse>, I>>(base?: I): NodeInfoResponse {
    return NodeInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeInfoResponse>, I>>(object: I): NodeInfoResponse {
    const message = createBaseNodeInfoResponse();
    message.peerId = object.peerId ?? "";
    message.maxFrame = (object.maxFrame !== undefined && object.maxFrame !== null)
      ? Long.fromValue(object.maxFrame)
      : Long.UZERO;
    message.peerScore = (object.peerScore !== undefined && object.peerScore !== null)
      ? Long.fromValue(object.peerScore)
      : Long.UZERO;
    message.version = object.version ?? new Uint8Array(0);
    return message;
  },
};

function createBasePutPeerInfoRequest(): PutPeerInfoRequest {
  return { peerInfo: [], uncooperativePeerInfo: [] };
}

export const PutPeerInfoRequest: MessageFns<PutPeerInfoRequest> = {
  encode(message: PutPeerInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.peerInfo) {
      PeerInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.uncooperativePeerInfo) {
      PeerInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutPeerInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutPeerInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerInfo.push(PeerInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uncooperativePeerInfo.push(PeerInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutPeerInfoRequest {
    return {
      peerInfo: globalThis.Array.isArray(object?.peerInfo) ? object.peerInfo.map((e: any) => PeerInfo.fromJSON(e)) : [],
      uncooperativePeerInfo: globalThis.Array.isArray(object?.uncooperativePeerInfo)
        ? object.uncooperativePeerInfo.map((e: any) => PeerInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PutPeerInfoRequest): unknown {
    const obj: any = {};
    if (message.peerInfo?.length) {
      obj.peerInfo = message.peerInfo.map((e) => PeerInfo.toJSON(e));
    }
    if (message.uncooperativePeerInfo?.length) {
      obj.uncooperativePeerInfo = message.uncooperativePeerInfo.map((e) => PeerInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutPeerInfoRequest>, I>>(base?: I): PutPeerInfoRequest {
    return PutPeerInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutPeerInfoRequest>, I>>(object: I): PutPeerInfoRequest {
    const message = createBasePutPeerInfoRequest();
    message.peerInfo = object.peerInfo?.map((e) => PeerInfo.fromPartial(e)) || [];
    message.uncooperativePeerInfo = object.uncooperativePeerInfo?.map((e) => PeerInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasePutNodeInfoRequest(): PutNodeInfoRequest {
  return { peerId: "", maxFrame: Long.UZERO, peerScore: Long.UZERO, signature: new Uint8Array(0) };
}

export const PutNodeInfoRequest: MessageFns<PutNodeInfoRequest> = {
  encode(message: PutNodeInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerId !== "") {
      writer.uint32(10).string(message.peerId);
    }
    if (!message.maxFrame.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.maxFrame.toString());
    }
    if (!message.peerScore.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.peerScore.toString());
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutNodeInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutNodeInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxFrame = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.peerScore = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutNodeInfoRequest {
    return {
      peerId: isSet(object.peerId) ? globalThis.String(object.peerId) : "",
      maxFrame: isSet(object.maxFrame) ? Long.fromValue(object.maxFrame) : Long.UZERO,
      peerScore: isSet(object.peerScore) ? Long.fromValue(object.peerScore) : Long.UZERO,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: PutNodeInfoRequest): unknown {
    const obj: any = {};
    if (message.peerId !== "") {
      obj.peerId = message.peerId;
    }
    if (!message.maxFrame.equals(Long.UZERO)) {
      obj.maxFrame = (message.maxFrame || Long.UZERO).toString();
    }
    if (!message.peerScore.equals(Long.UZERO)) {
      obj.peerScore = (message.peerScore || Long.UZERO).toString();
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutNodeInfoRequest>, I>>(base?: I): PutNodeInfoRequest {
    return PutNodeInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutNodeInfoRequest>, I>>(object: I): PutNodeInfoRequest {
    const message = createBasePutNodeInfoRequest();
    message.peerId = object.peerId ?? "";
    message.maxFrame = (object.maxFrame !== undefined && object.maxFrame !== null)
      ? Long.fromValue(object.maxFrame)
      : Long.UZERO;
    message.peerScore = (object.peerScore !== undefined && object.peerScore !== null)
      ? Long.fromValue(object.peerScore)
      : Long.UZERO;
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBasePutResponse(): PutResponse {
  return {};
}

export const PutResponse: MessageFns<PutResponse> = {
  encode(_: PutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PutResponse {
    return {};
  },

  toJSON(_: PutResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PutResponse>, I>>(base?: I): PutResponse {
    return PutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutResponse>, I>>(_: I): PutResponse {
    const message = createBasePutResponse();
    return message;
  },
};

function createBaseNetworkInfoResponse(): NetworkInfoResponse {
  return { networkInfo: [] };
}

export const NetworkInfoResponse: MessageFns<NetworkInfoResponse> = {
  encode(message: NetworkInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.networkInfo) {
      NetworkInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.networkInfo.push(NetworkInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkInfoResponse {
    return {
      networkInfo: globalThis.Array.isArray(object?.networkInfo)
        ? object.networkInfo.map((e: any) => NetworkInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NetworkInfoResponse): unknown {
    const obj: any = {};
    if (message.networkInfo?.length) {
      obj.networkInfo = message.networkInfo.map((e) => NetworkInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetworkInfoResponse>, I>>(base?: I): NetworkInfoResponse {
    return NetworkInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetworkInfoResponse>, I>>(object: I): NetworkInfoResponse {
    const message = createBaseNetworkInfoResponse();
    message.networkInfo = object.networkInfo?.map((e) => NetworkInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTokenInfoRequest(): GetTokenInfoRequest {
  return { address: new Uint8Array(0) };
}

export const GetTokenInfoRequest: MessageFns<GetTokenInfoRequest> = {
  encode(message: GetTokenInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokenInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenInfoRequest {
    return { address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0) };
  },

  toJSON(message: GetTokenInfoRequest): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenInfoRequest>, I>>(base?: I): GetTokenInfoRequest {
    return GetTokenInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenInfoRequest>, I>>(object: I): GetTokenInfoRequest {
    const message = createBaseGetTokenInfoRequest();
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokenInfoResponse(): TokenInfoResponse {
  return {
    confirmedTokenSupply: new Uint8Array(0),
    unconfirmedTokenSupply: new Uint8Array(0),
    ownedTokens: new Uint8Array(0),
    unconfirmedOwnedTokens: new Uint8Array(0),
  };
}

export const TokenInfoResponse: MessageFns<TokenInfoResponse> = {
  encode(message: TokenInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confirmedTokenSupply.length !== 0) {
      writer.uint32(10).bytes(message.confirmedTokenSupply);
    }
    if (message.unconfirmedTokenSupply.length !== 0) {
      writer.uint32(18).bytes(message.unconfirmedTokenSupply);
    }
    if (message.ownedTokens.length !== 0) {
      writer.uint32(26).bytes(message.ownedTokens);
    }
    if (message.unconfirmedOwnedTokens.length !== 0) {
      writer.uint32(34).bytes(message.unconfirmedOwnedTokens);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.confirmedTokenSupply = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unconfirmedTokenSupply = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownedTokens = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unconfirmedOwnedTokens = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenInfoResponse {
    return {
      confirmedTokenSupply: isSet(object.confirmedTokenSupply)
        ? bytesFromBase64(object.confirmedTokenSupply)
        : new Uint8Array(0),
      unconfirmedTokenSupply: isSet(object.unconfirmedTokenSupply)
        ? bytesFromBase64(object.unconfirmedTokenSupply)
        : new Uint8Array(0),
      ownedTokens: isSet(object.ownedTokens) ? bytesFromBase64(object.ownedTokens) : new Uint8Array(0),
      unconfirmedOwnedTokens: isSet(object.unconfirmedOwnedTokens)
        ? bytesFromBase64(object.unconfirmedOwnedTokens)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TokenInfoResponse): unknown {
    const obj: any = {};
    if (message.confirmedTokenSupply.length !== 0) {
      obj.confirmedTokenSupply = base64FromBytes(message.confirmedTokenSupply);
    }
    if (message.unconfirmedTokenSupply.length !== 0) {
      obj.unconfirmedTokenSupply = base64FromBytes(message.unconfirmedTokenSupply);
    }
    if (message.ownedTokens.length !== 0) {
      obj.ownedTokens = base64FromBytes(message.ownedTokens);
    }
    if (message.unconfirmedOwnedTokens.length !== 0) {
      obj.unconfirmedOwnedTokens = base64FromBytes(message.unconfirmedOwnedTokens);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenInfoResponse>, I>>(base?: I): TokenInfoResponse {
    return TokenInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenInfoResponse>, I>>(object: I): TokenInfoResponse {
    const message = createBaseTokenInfoResponse();
    message.confirmedTokenSupply = object.confirmedTokenSupply ?? new Uint8Array(0);
    message.unconfirmedTokenSupply = object.unconfirmedTokenSupply ?? new Uint8Array(0);
    message.ownedTokens = object.ownedTokens ?? new Uint8Array(0);
    message.unconfirmedOwnedTokens = object.unconfirmedOwnedTokens ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCapability(): Capability {
  return { protocolIdentifier: 0, additionalMetadata: new Uint8Array(0) };
}

export const Capability: MessageFns<Capability> = {
  encode(message: Capability, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolIdentifier !== 0) {
      writer.uint32(8).uint32(message.protocolIdentifier);
    }
    if (message.additionalMetadata.length !== 0) {
      writer.uint32(18).bytes(message.additionalMetadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Capability {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocolIdentifier = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.additionalMetadata = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Capability {
    return {
      protocolIdentifier: isSet(object.protocolIdentifier) ? globalThis.Number(object.protocolIdentifier) : 0,
      additionalMetadata: isSet(object.additionalMetadata)
        ? bytesFromBase64(object.additionalMetadata)
        : new Uint8Array(0),
    };
  },

  toJSON(message: Capability): unknown {
    const obj: any = {};
    if (message.protocolIdentifier !== 0) {
      obj.protocolIdentifier = Math.round(message.protocolIdentifier);
    }
    if (message.additionalMetadata.length !== 0) {
      obj.additionalMetadata = base64FromBytes(message.additionalMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Capability>, I>>(base?: I): Capability {
    return Capability.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Capability>, I>>(object: I): Capability {
    const message = createBaseCapability();
    message.protocolIdentifier = object.protocolIdentifier ?? 0;
    message.additionalMetadata = object.additionalMetadata ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSelfTestReport(): SelfTestReport {
  return {
    cores: 0,
    memory: new Uint8Array(0),
    storage: new Uint8Array(0),
    capabilities: [],
    masterHeadFrame: Long.UZERO,
    proverRange: new Uint8Array(0),
  };
}

export const SelfTestReport: MessageFns<SelfTestReport> = {
  encode(message: SelfTestReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cores !== 0) {
      writer.uint32(8).uint32(message.cores);
    }
    if (message.memory.length !== 0) {
      writer.uint32(18).bytes(message.memory);
    }
    if (message.storage.length !== 0) {
      writer.uint32(26).bytes(message.storage);
    }
    for (const v of message.capabilities) {
      Capability.encode(v!, writer.uint32(34).fork()).join();
    }
    if (!message.masterHeadFrame.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.masterHeadFrame.toString());
    }
    if (message.proverRange.length !== 0) {
      writer.uint32(50).bytes(message.proverRange);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelfTestReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelfTestReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cores = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.memory = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.storage = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.capabilities.push(Capability.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.masterHeadFrame = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.proverRange = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelfTestReport {
    return {
      cores: isSet(object.cores) ? globalThis.Number(object.cores) : 0,
      memory: isSet(object.memory) ? bytesFromBase64(object.memory) : new Uint8Array(0),
      storage: isSet(object.storage) ? bytesFromBase64(object.storage) : new Uint8Array(0),
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => Capability.fromJSON(e))
        : [],
      masterHeadFrame: isSet(object.masterHeadFrame) ? Long.fromValue(object.masterHeadFrame) : Long.UZERO,
      proverRange: isSet(object.proverRange) ? bytesFromBase64(object.proverRange) : new Uint8Array(0),
    };
  },

  toJSON(message: SelfTestReport): unknown {
    const obj: any = {};
    if (message.cores !== 0) {
      obj.cores = Math.round(message.cores);
    }
    if (message.memory.length !== 0) {
      obj.memory = base64FromBytes(message.memory);
    }
    if (message.storage.length !== 0) {
      obj.storage = base64FromBytes(message.storage);
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities.map((e) => Capability.toJSON(e));
    }
    if (!message.masterHeadFrame.equals(Long.UZERO)) {
      obj.masterHeadFrame = (message.masterHeadFrame || Long.UZERO).toString();
    }
    if (message.proverRange.length !== 0) {
      obj.proverRange = base64FromBytes(message.proverRange);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelfTestReport>, I>>(base?: I): SelfTestReport {
    return SelfTestReport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelfTestReport>, I>>(object: I): SelfTestReport {
    const message = createBaseSelfTestReport();
    message.cores = object.cores ?? 0;
    message.memory = object.memory ?? new Uint8Array(0);
    message.storage = object.storage ?? new Uint8Array(0);
    message.capabilities = object.capabilities?.map((e) => Capability.fromPartial(e)) || [];
    message.masterHeadFrame = (object.masterHeadFrame !== undefined && object.masterHeadFrame !== null)
      ? Long.fromValue(object.masterHeadFrame)
      : Long.UZERO;
    message.proverRange = object.proverRange ?? new Uint8Array(0);
    return message;
  },
};

function createBaseValidationMessage(): ValidationMessage {
  return { validation: new Uint8Array(0) };
}

export const ValidationMessage: MessageFns<ValidationMessage> = {
  encode(message: ValidationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validation.length !== 0) {
      writer.uint32(10).bytes(message.validation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validation = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationMessage {
    return { validation: isSet(object.validation) ? bytesFromBase64(object.validation) : new Uint8Array(0) };
  },

  toJSON(message: ValidationMessage): unknown {
    const obj: any = {};
    if (message.validation.length !== 0) {
      obj.validation = base64FromBytes(message.validation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidationMessage>, I>>(base?: I): ValidationMessage {
    return ValidationMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidationMessage>, I>>(object: I): ValidationMessage {
    const message = createBaseValidationMessage();
    message.validation = object.validation ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSyncRequest(): SyncRequest {
  return { framesRequest: undefined };
}

export const SyncRequest: MessageFns<SyncRequest> = {
  encode(message: SyncRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.framesRequest !== undefined) {
      ClockFramesRequest.encode(message.framesRequest, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.framesRequest = ClockFramesRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncRequest {
    return {
      framesRequest: isSet(object.framesRequest) ? ClockFramesRequest.fromJSON(object.framesRequest) : undefined,
    };
  },

  toJSON(message: SyncRequest): unknown {
    const obj: any = {};
    if (message.framesRequest !== undefined) {
      obj.framesRequest = ClockFramesRequest.toJSON(message.framesRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncRequest>, I>>(base?: I): SyncRequest {
    return SyncRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncRequest>, I>>(object: I): SyncRequest {
    const message = createBaseSyncRequest();
    message.framesRequest = (object.framesRequest !== undefined && object.framesRequest !== null)
      ? ClockFramesRequest.fromPartial(object.framesRequest)
      : undefined;
    return message;
  },
};

function createBaseSyncResponse(): SyncResponse {
  return { framesResponse: undefined };
}

export const SyncResponse: MessageFns<SyncResponse> = {
  encode(message: SyncResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.framesResponse !== undefined) {
      ClockFramesResponse.encode(message.framesResponse, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.framesResponse = ClockFramesResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncResponse {
    return {
      framesResponse: isSet(object.framesResponse) ? ClockFramesResponse.fromJSON(object.framesResponse) : undefined,
    };
  },

  toJSON(message: SyncResponse): unknown {
    const obj: any = {};
    if (message.framesResponse !== undefined) {
      obj.framesResponse = ClockFramesResponse.toJSON(message.framesResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncResponse>, I>>(base?: I): SyncResponse {
    return SyncResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncResponse>, I>>(object: I): SyncResponse {
    const message = createBaseSyncResponse();
    message.framesResponse = (object.framesResponse !== undefined && object.framesResponse !== null)
      ? ClockFramesResponse.fromPartial(object.framesResponse)
      : undefined;
    return message;
  },
};

function createBaseGetPeerManifestsRequest(): GetPeerManifestsRequest {
  return {};
}

export const GetPeerManifestsRequest: MessageFns<GetPeerManifestsRequest> = {
  encode(_: GetPeerManifestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPeerManifestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPeerManifestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetPeerManifestsRequest {
    return {};
  },

  toJSON(_: GetPeerManifestsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPeerManifestsRequest>, I>>(base?: I): GetPeerManifestsRequest {
    return GetPeerManifestsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPeerManifestsRequest>, I>>(_: I): GetPeerManifestsRequest {
    const message = createBaseGetPeerManifestsRequest();
    return message;
  },
};

function createBasePeerManifest(): PeerManifest {
  return {
    peerId: new Uint8Array(0),
    cores: 0,
    memory: new Uint8Array(0),
    storage: new Uint8Array(0),
    capabilities: [],
    masterHeadFrame: Long.UZERO,
    lastSeen: Long.ZERO,
    increment: 0,
  };
}

export const PeerManifest: MessageFns<PeerManifest> = {
  encode(message: PeerManifest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerId.length !== 0) {
      writer.uint32(10).bytes(message.peerId);
    }
    if (message.cores !== 0) {
      writer.uint32(16).uint32(message.cores);
    }
    if (message.memory.length !== 0) {
      writer.uint32(26).bytes(message.memory);
    }
    if (message.storage.length !== 0) {
      writer.uint32(34).bytes(message.storage);
    }
    for (const v of message.capabilities) {
      Capability.encode(v!, writer.uint32(42).fork()).join();
    }
    if (!message.masterHeadFrame.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.masterHeadFrame.toString());
    }
    if (!message.lastSeen.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.lastSeen.toString());
    }
    if (message.increment !== 0) {
      writer.uint32(64).uint32(message.increment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeerManifest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeerManifest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cores = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.memory = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.storage = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.capabilities.push(Capability.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.masterHeadFrame = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lastSeen = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.increment = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeerManifest {
    return {
      peerId: isSet(object.peerId) ? bytesFromBase64(object.peerId) : new Uint8Array(0),
      cores: isSet(object.cores) ? globalThis.Number(object.cores) : 0,
      memory: isSet(object.memory) ? bytesFromBase64(object.memory) : new Uint8Array(0),
      storage: isSet(object.storage) ? bytesFromBase64(object.storage) : new Uint8Array(0),
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => Capability.fromJSON(e))
        : [],
      masterHeadFrame: isSet(object.masterHeadFrame) ? Long.fromValue(object.masterHeadFrame) : Long.UZERO,
      lastSeen: isSet(object.lastSeen) ? Long.fromValue(object.lastSeen) : Long.ZERO,
      increment: isSet(object.increment) ? globalThis.Number(object.increment) : 0,
    };
  },

  toJSON(message: PeerManifest): unknown {
    const obj: any = {};
    if (message.peerId.length !== 0) {
      obj.peerId = base64FromBytes(message.peerId);
    }
    if (message.cores !== 0) {
      obj.cores = Math.round(message.cores);
    }
    if (message.memory.length !== 0) {
      obj.memory = base64FromBytes(message.memory);
    }
    if (message.storage.length !== 0) {
      obj.storage = base64FromBytes(message.storage);
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities.map((e) => Capability.toJSON(e));
    }
    if (!message.masterHeadFrame.equals(Long.UZERO)) {
      obj.masterHeadFrame = (message.masterHeadFrame || Long.UZERO).toString();
    }
    if (!message.lastSeen.equals(Long.ZERO)) {
      obj.lastSeen = (message.lastSeen || Long.ZERO).toString();
    }
    if (message.increment !== 0) {
      obj.increment = Math.round(message.increment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeerManifest>, I>>(base?: I): PeerManifest {
    return PeerManifest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeerManifest>, I>>(object: I): PeerManifest {
    const message = createBasePeerManifest();
    message.peerId = object.peerId ?? new Uint8Array(0);
    message.cores = object.cores ?? 0;
    message.memory = object.memory ?? new Uint8Array(0);
    message.storage = object.storage ?? new Uint8Array(0);
    message.capabilities = object.capabilities?.map((e) => Capability.fromPartial(e)) || [];
    message.masterHeadFrame = (object.masterHeadFrame !== undefined && object.masterHeadFrame !== null)
      ? Long.fromValue(object.masterHeadFrame)
      : Long.UZERO;
    message.lastSeen = (object.lastSeen !== undefined && object.lastSeen !== null)
      ? Long.fromValue(object.lastSeen)
      : Long.ZERO;
    message.increment = object.increment ?? 0;
    return message;
  },
};

function createBaseAnnounceProverRequest(): AnnounceProverRequest {
  return { publicKeySignaturesEd448: [], initialProof: undefined };
}

export const AnnounceProverRequest: MessageFns<AnnounceProverRequest> = {
  encode(message: AnnounceProverRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.publicKeySignaturesEd448) {
      Ed448Signature.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.initialProof !== undefined) {
      MintCoinRequest.encode(message.initialProof, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnounceProverRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnounceProverRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKeySignaturesEd448.push(Ed448Signature.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.initialProof = MintCoinRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnounceProverRequest {
    return {
      publicKeySignaturesEd448: globalThis.Array.isArray(object?.publicKeySignaturesEd448)
        ? object.publicKeySignaturesEd448.map((e: any) => Ed448Signature.fromJSON(e))
        : [],
      initialProof: isSet(object.initialProof) ? MintCoinRequest.fromJSON(object.initialProof) : undefined,
    };
  },

  toJSON(message: AnnounceProverRequest): unknown {
    const obj: any = {};
    if (message.publicKeySignaturesEd448?.length) {
      obj.publicKeySignaturesEd448 = message.publicKeySignaturesEd448.map((e) => Ed448Signature.toJSON(e));
    }
    if (message.initialProof !== undefined) {
      obj.initialProof = MintCoinRequest.toJSON(message.initialProof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnounceProverRequest>, I>>(base?: I): AnnounceProverRequest {
    return AnnounceProverRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnounceProverRequest>, I>>(object: I): AnnounceProverRequest {
    const message = createBaseAnnounceProverRequest();
    message.publicKeySignaturesEd448 = object.publicKeySignaturesEd448?.map((e) => Ed448Signature.fromPartial(e)) || [];
    message.initialProof = (object.initialProof !== undefined && object.initialProof !== null)
      ? MintCoinRequest.fromPartial(object.initialProof)
      : undefined;
    return message;
  },
};

function createBaseAnnounceProverJoin(): AnnounceProverJoin {
  return { filter: new Uint8Array(0), frameNumber: Long.UZERO, publicKeySignatureEd448: undefined };
}

export const AnnounceProverJoin: MessageFns<AnnounceProverJoin> = {
  encode(message: AnnounceProverJoin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter.length !== 0) {
      writer.uint32(10).bytes(message.filter);
    }
    if (!message.frameNumber.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.frameNumber.toString());
    }
    if (message.publicKeySignatureEd448 !== undefined) {
      Ed448Signature.encode(message.publicKeySignatureEd448, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnounceProverJoin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnounceProverJoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.frameNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKeySignatureEd448 = Ed448Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnounceProverJoin {
    return {
      filter: isSet(object.filter) ? bytesFromBase64(object.filter) : new Uint8Array(0),
      frameNumber: isSet(object.frameNumber) ? Long.fromValue(object.frameNumber) : Long.UZERO,
      publicKeySignatureEd448: isSet(object.publicKeySignatureEd448)
        ? Ed448Signature.fromJSON(object.publicKeySignatureEd448)
        : undefined,
    };
  },

  toJSON(message: AnnounceProverJoin): unknown {
    const obj: any = {};
    if (message.filter.length !== 0) {
      obj.filter = base64FromBytes(message.filter);
    }
    if (!message.frameNumber.equals(Long.UZERO)) {
      obj.frameNumber = (message.frameNumber || Long.UZERO).toString();
    }
    if (message.publicKeySignatureEd448 !== undefined) {
      obj.publicKeySignatureEd448 = Ed448Signature.toJSON(message.publicKeySignatureEd448);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnounceProverJoin>, I>>(base?: I): AnnounceProverJoin {
    return AnnounceProverJoin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnounceProverJoin>, I>>(object: I): AnnounceProverJoin {
    const message = createBaseAnnounceProverJoin();
    message.filter = object.filter ?? new Uint8Array(0);
    message.frameNumber = (object.frameNumber !== undefined && object.frameNumber !== null)
      ? Long.fromValue(object.frameNumber)
      : Long.UZERO;
    message.publicKeySignatureEd448 =
      (object.publicKeySignatureEd448 !== undefined && object.publicKeySignatureEd448 !== null)
        ? Ed448Signature.fromPartial(object.publicKeySignatureEd448)
        : undefined;
    return message;
  },
};

function createBaseAnnounceProverLeave(): AnnounceProverLeave {
  return { filter: new Uint8Array(0), frameNumber: Long.UZERO, publicKeySignatureEd448: undefined };
}

export const AnnounceProverLeave: MessageFns<AnnounceProverLeave> = {
  encode(message: AnnounceProverLeave, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter.length !== 0) {
      writer.uint32(10).bytes(message.filter);
    }
    if (!message.frameNumber.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.frameNumber.toString());
    }
    if (message.publicKeySignatureEd448 !== undefined) {
      Ed448Signature.encode(message.publicKeySignatureEd448, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnounceProverLeave {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnounceProverLeave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.frameNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKeySignatureEd448 = Ed448Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnounceProverLeave {
    return {
      filter: isSet(object.filter) ? bytesFromBase64(object.filter) : new Uint8Array(0),
      frameNumber: isSet(object.frameNumber) ? Long.fromValue(object.frameNumber) : Long.UZERO,
      publicKeySignatureEd448: isSet(object.publicKeySignatureEd448)
        ? Ed448Signature.fromJSON(object.publicKeySignatureEd448)
        : undefined,
    };
  },

  toJSON(message: AnnounceProverLeave): unknown {
    const obj: any = {};
    if (message.filter.length !== 0) {
      obj.filter = base64FromBytes(message.filter);
    }
    if (!message.frameNumber.equals(Long.UZERO)) {
      obj.frameNumber = (message.frameNumber || Long.UZERO).toString();
    }
    if (message.publicKeySignatureEd448 !== undefined) {
      obj.publicKeySignatureEd448 = Ed448Signature.toJSON(message.publicKeySignatureEd448);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnounceProverLeave>, I>>(base?: I): AnnounceProverLeave {
    return AnnounceProverLeave.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnounceProverLeave>, I>>(object: I): AnnounceProverLeave {
    const message = createBaseAnnounceProverLeave();
    message.filter = object.filter ?? new Uint8Array(0);
    message.frameNumber = (object.frameNumber !== undefined && object.frameNumber !== null)
      ? Long.fromValue(object.frameNumber)
      : Long.UZERO;
    message.publicKeySignatureEd448 =
      (object.publicKeySignatureEd448 !== undefined && object.publicKeySignatureEd448 !== null)
        ? Ed448Signature.fromPartial(object.publicKeySignatureEd448)
        : undefined;
    return message;
  },
};

function createBaseAnnounceProverPause(): AnnounceProverPause {
  return { filter: new Uint8Array(0), frameNumber: Long.UZERO, publicKeySignatureEd448: undefined };
}

export const AnnounceProverPause: MessageFns<AnnounceProverPause> = {
  encode(message: AnnounceProverPause, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter.length !== 0) {
      writer.uint32(10).bytes(message.filter);
    }
    if (!message.frameNumber.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.frameNumber.toString());
    }
    if (message.publicKeySignatureEd448 !== undefined) {
      Ed448Signature.encode(message.publicKeySignatureEd448, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnounceProverPause {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnounceProverPause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.frameNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKeySignatureEd448 = Ed448Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnounceProverPause {
    return {
      filter: isSet(object.filter) ? bytesFromBase64(object.filter) : new Uint8Array(0),
      frameNumber: isSet(object.frameNumber) ? Long.fromValue(object.frameNumber) : Long.UZERO,
      publicKeySignatureEd448: isSet(object.publicKeySignatureEd448)
        ? Ed448Signature.fromJSON(object.publicKeySignatureEd448)
        : undefined,
    };
  },

  toJSON(message: AnnounceProverPause): unknown {
    const obj: any = {};
    if (message.filter.length !== 0) {
      obj.filter = base64FromBytes(message.filter);
    }
    if (!message.frameNumber.equals(Long.UZERO)) {
      obj.frameNumber = (message.frameNumber || Long.UZERO).toString();
    }
    if (message.publicKeySignatureEd448 !== undefined) {
      obj.publicKeySignatureEd448 = Ed448Signature.toJSON(message.publicKeySignatureEd448);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnounceProverPause>, I>>(base?: I): AnnounceProverPause {
    return AnnounceProverPause.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnounceProverPause>, I>>(object: I): AnnounceProverPause {
    const message = createBaseAnnounceProverPause();
    message.filter = object.filter ?? new Uint8Array(0);
    message.frameNumber = (object.frameNumber !== undefined && object.frameNumber !== null)
      ? Long.fromValue(object.frameNumber)
      : Long.UZERO;
    message.publicKeySignatureEd448 =
      (object.publicKeySignatureEd448 !== undefined && object.publicKeySignatureEd448 !== null)
        ? Ed448Signature.fromPartial(object.publicKeySignatureEd448)
        : undefined;
    return message;
  },
};

function createBaseAnnounceProverResume(): AnnounceProverResume {
  return { filter: new Uint8Array(0), frameNumber: Long.UZERO, publicKeySignatureEd448: undefined };
}

export const AnnounceProverResume: MessageFns<AnnounceProverResume> = {
  encode(message: AnnounceProverResume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter.length !== 0) {
      writer.uint32(10).bytes(message.filter);
    }
    if (!message.frameNumber.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.frameNumber.toString());
    }
    if (message.publicKeySignatureEd448 !== undefined) {
      Ed448Signature.encode(message.publicKeySignatureEd448, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnounceProverResume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnounceProverResume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.frameNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKeySignatureEd448 = Ed448Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnounceProverResume {
    return {
      filter: isSet(object.filter) ? bytesFromBase64(object.filter) : new Uint8Array(0),
      frameNumber: isSet(object.frameNumber) ? Long.fromValue(object.frameNumber) : Long.UZERO,
      publicKeySignatureEd448: isSet(object.publicKeySignatureEd448)
        ? Ed448Signature.fromJSON(object.publicKeySignatureEd448)
        : undefined,
    };
  },

  toJSON(message: AnnounceProverResume): unknown {
    const obj: any = {};
    if (message.filter.length !== 0) {
      obj.filter = base64FromBytes(message.filter);
    }
    if (!message.frameNumber.equals(Long.UZERO)) {
      obj.frameNumber = (message.frameNumber || Long.UZERO).toString();
    }
    if (message.publicKeySignatureEd448 !== undefined) {
      obj.publicKeySignatureEd448 = Ed448Signature.toJSON(message.publicKeySignatureEd448);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnounceProverResume>, I>>(base?: I): AnnounceProverResume {
    return AnnounceProverResume.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnounceProverResume>, I>>(object: I): AnnounceProverResume {
    const message = createBaseAnnounceProverResume();
    message.filter = object.filter ?? new Uint8Array(0);
    message.frameNumber = (object.frameNumber !== undefined && object.frameNumber !== null)
      ? Long.fromValue(object.frameNumber)
      : Long.UZERO;
    message.publicKeySignatureEd448 =
      (object.publicKeySignatureEd448 !== undefined && object.publicKeySignatureEd448 !== null)
        ? Ed448Signature.fromPartial(object.publicKeySignatureEd448)
        : undefined;
    return message;
  },
};

function createBaseOriginatedAccountRef(): OriginatedAccountRef {
  return { address: new Uint8Array(0) };
}

export const OriginatedAccountRef: MessageFns<OriginatedAccountRef> = {
  encode(message: OriginatedAccountRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OriginatedAccountRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOriginatedAccountRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OriginatedAccountRef {
    return { address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0) };
  },

  toJSON(message: OriginatedAccountRef): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OriginatedAccountRef>, I>>(base?: I): OriginatedAccountRef {
    return OriginatedAccountRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OriginatedAccountRef>, I>>(object: I): OriginatedAccountRef {
    const message = createBaseOriginatedAccountRef();
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseImplicitAccount(): ImplicitAccount {
  return { implicitType: 0, address: new Uint8Array(0), domain: new Uint8Array(0) };
}

export const ImplicitAccount: MessageFns<ImplicitAccount> = {
  encode(message: ImplicitAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.implicitType !== 0) {
      writer.uint32(8).uint32(message.implicitType);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    if (message.domain.length !== 0) {
      writer.uint32(26).bytes(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImplicitAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImplicitAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.implicitType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.domain = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImplicitAccount {
    return {
      implicitType: isSet(object.implicitType) ? globalThis.Number(object.implicitType) : 0,
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
      domain: isSet(object.domain) ? bytesFromBase64(object.domain) : new Uint8Array(0),
    };
  },

  toJSON(message: ImplicitAccount): unknown {
    const obj: any = {};
    if (message.implicitType !== 0) {
      obj.implicitType = Math.round(message.implicitType);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.domain.length !== 0) {
      obj.domain = base64FromBytes(message.domain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImplicitAccount>, I>>(base?: I): ImplicitAccount {
    return ImplicitAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImplicitAccount>, I>>(object: I): ImplicitAccount {
    const message = createBaseImplicitAccount();
    message.implicitType = object.implicitType ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    message.domain = object.domain ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAccountRef(): AccountRef {
  return { originatedAccount: undefined, implicitAccount: undefined };
}

export const AccountRef: MessageFns<AccountRef> = {
  encode(message: AccountRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originatedAccount !== undefined) {
      OriginatedAccountRef.encode(message.originatedAccount, writer.uint32(10).fork()).join();
    }
    if (message.implicitAccount !== undefined) {
      ImplicitAccount.encode(message.implicitAccount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.originatedAccount = OriginatedAccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.implicitAccount = ImplicitAccount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountRef {
    return {
      originatedAccount: isSet(object.originatedAccount)
        ? OriginatedAccountRef.fromJSON(object.originatedAccount)
        : undefined,
      implicitAccount: isSet(object.implicitAccount) ? ImplicitAccount.fromJSON(object.implicitAccount) : undefined,
    };
  },

  toJSON(message: AccountRef): unknown {
    const obj: any = {};
    if (message.originatedAccount !== undefined) {
      obj.originatedAccount = OriginatedAccountRef.toJSON(message.originatedAccount);
    }
    if (message.implicitAccount !== undefined) {
      obj.implicitAccount = ImplicitAccount.toJSON(message.implicitAccount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountRef>, I>>(base?: I): AccountRef {
    return AccountRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountRef>, I>>(object: I): AccountRef {
    const message = createBaseAccountRef();
    message.originatedAccount = (object.originatedAccount !== undefined && object.originatedAccount !== null)
      ? OriginatedAccountRef.fromPartial(object.originatedAccount)
      : undefined;
    message.implicitAccount = (object.implicitAccount !== undefined && object.implicitAccount !== null)
      ? ImplicitAccount.fromPartial(object.implicitAccount)
      : undefined;
    return message;
  },
};

function createBaseAccountAllowanceRef(): AccountAllowanceRef {
  return { address: new Uint8Array(0) };
}

export const AccountAllowanceRef: MessageFns<AccountAllowanceRef> = {
  encode(message: AccountAllowanceRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountAllowanceRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountAllowanceRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountAllowanceRef {
    return { address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0) };
  },

  toJSON(message: AccountAllowanceRef): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountAllowanceRef>, I>>(base?: I): AccountAllowanceRef {
    return AccountAllowanceRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountAllowanceRef>, I>>(object: I): AccountAllowanceRef {
    const message = createBaseAccountAllowanceRef();
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCoinAllowanceRef(): CoinAllowanceRef {
  return { address: new Uint8Array(0) };
}

export const CoinAllowanceRef: MessageFns<CoinAllowanceRef> = {
  encode(message: CoinAllowanceRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoinAllowanceRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinAllowanceRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoinAllowanceRef {
    return { address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0) };
  },

  toJSON(message: CoinAllowanceRef): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoinAllowanceRef>, I>>(base?: I): CoinAllowanceRef {
    return CoinAllowanceRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoinAllowanceRef>, I>>(object: I): CoinAllowanceRef {
    const message = createBaseCoinAllowanceRef();
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCoin(): Coin {
  return { amount: new Uint8Array(0), intersection: new Uint8Array(0), owner: undefined };
}

export const Coin: MessageFns<Coin> = {
  encode(message: Coin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount.length !== 0) {
      writer.uint32(10).bytes(message.amount);
    }
    if (message.intersection.length !== 0) {
      writer.uint32(18).bytes(message.intersection);
    }
    if (message.owner !== undefined) {
      AccountRef.encode(message.owner, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Coin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.intersection = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = AccountRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Coin {
    return {
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      intersection: isSet(object.intersection) ? bytesFromBase64(object.intersection) : new Uint8Array(0),
      owner: isSet(object.owner) ? AccountRef.fromJSON(object.owner) : undefined,
    };
  },

  toJSON(message: Coin): unknown {
    const obj: any = {};
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.intersection.length !== 0) {
      obj.intersection = base64FromBytes(message.intersection);
    }
    if (message.owner !== undefined) {
      obj.owner = AccountRef.toJSON(message.owner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Coin>, I>>(base?: I): Coin {
    return Coin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Coin>, I>>(object: I): Coin {
    const message = createBaseCoin();
    message.amount = object.amount ?? new Uint8Array(0);
    message.intersection = object.intersection ?? new Uint8Array(0);
    message.owner = (object.owner !== undefined && object.owner !== null)
      ? AccountRef.fromPartial(object.owner)
      : undefined;
    return message;
  },
};

function createBaseTokenRequest(): TokenRequest {
  return { transfer: undefined, split: undefined, merge: undefined, mint: undefined, announce: undefined };
}

export const TokenRequest: MessageFns<TokenRequest> = {
  encode(message: TokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      TransferCoinRequest.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    if (message.split !== undefined) {
      SplitCoinRequest.encode(message.split, writer.uint32(18).fork()).join();
    }
    if (message.merge !== undefined) {
      MergeCoinRequest.encode(message.merge, writer.uint32(26).fork()).join();
    }
    if (message.mint !== undefined) {
      MintCoinRequest.encode(message.mint, writer.uint32(34).fork()).join();
    }
    if (message.announce !== undefined) {
      AnnounceProverRequest.encode(message.announce, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = TransferCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.split = SplitCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.merge = MergeCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mint = MintCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.announce = AnnounceProverRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenRequest {
    return {
      transfer: isSet(object.transfer) ? TransferCoinRequest.fromJSON(object.transfer) : undefined,
      split: isSet(object.split) ? SplitCoinRequest.fromJSON(object.split) : undefined,
      merge: isSet(object.merge) ? MergeCoinRequest.fromJSON(object.merge) : undefined,
      mint: isSet(object.mint) ? MintCoinRequest.fromJSON(object.mint) : undefined,
      announce: isSet(object.announce) ? AnnounceProverRequest.fromJSON(object.announce) : undefined,
    };
  },

  toJSON(message: TokenRequest): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = TransferCoinRequest.toJSON(message.transfer);
    }
    if (message.split !== undefined) {
      obj.split = SplitCoinRequest.toJSON(message.split);
    }
    if (message.merge !== undefined) {
      obj.merge = MergeCoinRequest.toJSON(message.merge);
    }
    if (message.mint !== undefined) {
      obj.mint = MintCoinRequest.toJSON(message.mint);
    }
    if (message.announce !== undefined) {
      obj.announce = AnnounceProverRequest.toJSON(message.announce);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenRequest>, I>>(base?: I): TokenRequest {
    return TokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenRequest>, I>>(object: I): TokenRequest {
    const message = createBaseTokenRequest();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? TransferCoinRequest.fromPartial(object.transfer)
      : undefined;
    message.split = (object.split !== undefined && object.split !== null)
      ? SplitCoinRequest.fromPartial(object.split)
      : undefined;
    message.merge = (object.merge !== undefined && object.merge !== null)
      ? MergeCoinRequest.fromPartial(object.merge)
      : undefined;
    message.mint = (object.mint !== undefined && object.mint !== null)
      ? MintCoinRequest.fromPartial(object.mint)
      : undefined;
    message.announce = (object.announce !== undefined && object.announce !== null)
      ? AnnounceProverRequest.fromPartial(object.announce)
      : undefined;
    return message;
  },
};

function createBaseTokenRequests(): TokenRequests {
  return { requests: [] };
}

export const TokenRequests: MessageFns<TokenRequests> = {
  encode(message: TokenRequests, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      TokenRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenRequests {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenRequests();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(TokenRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenRequests {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => TokenRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TokenRequests): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => TokenRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenRequests>, I>>(base?: I): TokenRequests {
    return TokenRequests.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenRequests>, I>>(object: I): TokenRequests {
    const message = createBaseTokenRequests();
    message.requests = object.requests?.map((e) => TokenRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBasePreCoinProof(): PreCoinProof {
  return {
    amount: new Uint8Array(0),
    index: 0,
    indexProof: new Uint8Array(0),
    commitment: new Uint8Array(0),
    proof: new Uint8Array(0),
    parallelism: 0,
    difficulty: 0,
    owner: undefined,
  };
}

export const PreCoinProof: MessageFns<PreCoinProof> = {
  encode(message: PreCoinProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount.length !== 0) {
      writer.uint32(10).bytes(message.amount);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    if (message.indexProof.length !== 0) {
      writer.uint32(26).bytes(message.indexProof);
    }
    if (message.commitment.length !== 0) {
      writer.uint32(34).bytes(message.commitment);
    }
    if (message.proof.length !== 0) {
      writer.uint32(42).bytes(message.proof);
    }
    if (message.parallelism !== 0) {
      writer.uint32(48).uint32(message.parallelism);
    }
    if (message.difficulty !== 0) {
      writer.uint32(56).uint32(message.difficulty);
    }
    if (message.owner !== undefined) {
      AccountRef.encode(message.owner, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreCoinProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreCoinProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.indexProof = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commitment = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.proof = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.parallelism = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.difficulty = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.owner = AccountRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreCoinProof {
    return {
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      indexProof: isSet(object.indexProof) ? bytesFromBase64(object.indexProof) : new Uint8Array(0),
      commitment: isSet(object.commitment) ? bytesFromBase64(object.commitment) : new Uint8Array(0),
      proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(0),
      parallelism: isSet(object.parallelism) ? globalThis.Number(object.parallelism) : 0,
      difficulty: isSet(object.difficulty) ? globalThis.Number(object.difficulty) : 0,
      owner: isSet(object.owner) ? AccountRef.fromJSON(object.owner) : undefined,
    };
  },

  toJSON(message: PreCoinProof): unknown {
    const obj: any = {};
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.indexProof.length !== 0) {
      obj.indexProof = base64FromBytes(message.indexProof);
    }
    if (message.commitment.length !== 0) {
      obj.commitment = base64FromBytes(message.commitment);
    }
    if (message.proof.length !== 0) {
      obj.proof = base64FromBytes(message.proof);
    }
    if (message.parallelism !== 0) {
      obj.parallelism = Math.round(message.parallelism);
    }
    if (message.difficulty !== 0) {
      obj.difficulty = Math.round(message.difficulty);
    }
    if (message.owner !== undefined) {
      obj.owner = AccountRef.toJSON(message.owner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreCoinProof>, I>>(base?: I): PreCoinProof {
    return PreCoinProof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreCoinProof>, I>>(object: I): PreCoinProof {
    const message = createBasePreCoinProof();
    message.amount = object.amount ?? new Uint8Array(0);
    message.index = object.index ?? 0;
    message.indexProof = object.indexProof ?? new Uint8Array(0);
    message.commitment = object.commitment ?? new Uint8Array(0);
    message.proof = object.proof ?? new Uint8Array(0);
    message.parallelism = object.parallelism ?? 0;
    message.difficulty = object.difficulty ?? 0;
    message.owner = (object.owner !== undefined && object.owner !== null)
      ? AccountRef.fromPartial(object.owner)
      : undefined;
    return message;
  },
};

function createBaseTokenOutput(): TokenOutput {
  return { coin: undefined, proof: undefined, deletedCoin: undefined, deletedProof: undefined };
}

export const TokenOutput: MessageFns<TokenOutput> = {
  encode(message: TokenOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coin !== undefined) {
      Coin.encode(message.coin, writer.uint32(10).fork()).join();
    }
    if (message.proof !== undefined) {
      PreCoinProof.encode(message.proof, writer.uint32(18).fork()).join();
    }
    if (message.deletedCoin !== undefined) {
      CoinRef.encode(message.deletedCoin, writer.uint32(26).fork()).join();
    }
    if (message.deletedProof !== undefined) {
      PreCoinProof.encode(message.deletedProof, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coin = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proof = PreCoinProof.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deletedCoin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deletedProof = PreCoinProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenOutput {
    return {
      coin: isSet(object.coin) ? Coin.fromJSON(object.coin) : undefined,
      proof: isSet(object.proof) ? PreCoinProof.fromJSON(object.proof) : undefined,
      deletedCoin: isSet(object.deletedCoin) ? CoinRef.fromJSON(object.deletedCoin) : undefined,
      deletedProof: isSet(object.deletedProof) ? PreCoinProof.fromJSON(object.deletedProof) : undefined,
    };
  },

  toJSON(message: TokenOutput): unknown {
    const obj: any = {};
    if (message.coin !== undefined) {
      obj.coin = Coin.toJSON(message.coin);
    }
    if (message.proof !== undefined) {
      obj.proof = PreCoinProof.toJSON(message.proof);
    }
    if (message.deletedCoin !== undefined) {
      obj.deletedCoin = CoinRef.toJSON(message.deletedCoin);
    }
    if (message.deletedProof !== undefined) {
      obj.deletedProof = PreCoinProof.toJSON(message.deletedProof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenOutput>, I>>(base?: I): TokenOutput {
    return TokenOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenOutput>, I>>(object: I): TokenOutput {
    const message = createBaseTokenOutput();
    message.coin = (object.coin !== undefined && object.coin !== null) ? Coin.fromPartial(object.coin) : undefined;
    message.proof = (object.proof !== undefined && object.proof !== null)
      ? PreCoinProof.fromPartial(object.proof)
      : undefined;
    message.deletedCoin = (object.deletedCoin !== undefined && object.deletedCoin !== null)
      ? CoinRef.fromPartial(object.deletedCoin)
      : undefined;
    message.deletedProof = (object.deletedProof !== undefined && object.deletedProof !== null)
      ? PreCoinProof.fromPartial(object.deletedProof)
      : undefined;
    return message;
  },
};

function createBaseTokenOutputs(): TokenOutputs {
  return { outputs: [] };
}

export const TokenOutputs: MessageFns<TokenOutputs> = {
  encode(message: TokenOutputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outputs) {
      TokenOutput.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenOutputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenOutputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputs.push(TokenOutput.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenOutputs {
    return {
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => TokenOutput.fromJSON(e)) : [],
    };
  },

  toJSON(message: TokenOutputs): unknown {
    const obj: any = {};
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => TokenOutput.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenOutputs>, I>>(base?: I): TokenOutputs {
    return TokenOutputs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenOutputs>, I>>(object: I): TokenOutputs {
    const message = createBaseTokenOutputs();
    message.outputs = object.outputs?.map((e) => TokenOutput.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCoinRef(): CoinRef {
  return { address: new Uint8Array(0) };
}

export const CoinRef: MessageFns<CoinRef> = {
  encode(message: CoinRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoinRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoinRef {
    return { address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0) };
  },

  toJSON(message: CoinRef): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoinRef>, I>>(base?: I): CoinRef {
    return CoinRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoinRef>, I>>(object: I): CoinRef {
    const message = createBaseCoinRef();
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBasePendingTransactionRef(): PendingTransactionRef {
  return { address: new Uint8Array(0) };
}

export const PendingTransactionRef: MessageFns<PendingTransactionRef> = {
  encode(message: PendingTransactionRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingTransactionRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingTransactionRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingTransactionRef {
    return { address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0) };
  },

  toJSON(message: PendingTransactionRef): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingTransactionRef>, I>>(base?: I): PendingTransactionRef {
    return PendingTransactionRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingTransactionRef>, I>>(object: I): PendingTransactionRef {
    const message = createBasePendingTransactionRef();
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseKeyRef(): KeyRef {
  return { address: new Uint8Array(0) };
}

export const KeyRef: MessageFns<KeyRef> = {
  encode(message: KeyRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyRef {
    return { address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0) };
  },

  toJSON(message: KeyRef): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyRef>, I>>(base?: I): KeyRef {
    return KeyRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyRef>, I>>(object: I): KeyRef {
    const message = createBaseKeyRef();
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignature(): Signature {
  return { signatureType: 0, signature: new Uint8Array(0), key: undefined };
}

export const Signature: MessageFns<Signature> = {
  encode(message: Signature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signatureType !== 0) {
      writer.uint32(8).uint32(message.signatureType);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.key !== undefined) {
      KeyRef.encode(message.key, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.signatureType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key = KeyRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signature {
    return {
      signatureType: isSet(object.signatureType) ? globalThis.Number(object.signatureType) : 0,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      key: isSet(object.key) ? KeyRef.fromJSON(object.key) : undefined,
    };
  },

  toJSON(message: Signature): unknown {
    const obj: any = {};
    if (message.signatureType !== 0) {
      obj.signatureType = Math.round(message.signatureType);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.key !== undefined) {
      obj.key = KeyRef.toJSON(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signature>, I>>(base?: I): Signature {
    return Signature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signature>, I>>(object: I): Signature {
    const message = createBaseSignature();
    message.signatureType = object.signatureType ?? 0;
    message.signature = object.signature ?? new Uint8Array(0);
    message.key = (object.key !== undefined && object.key !== null) ? KeyRef.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBasePeerManifestsResponse(): PeerManifestsResponse {
  return { peerManifests: [] };
}

export const PeerManifestsResponse: MessageFns<PeerManifestsResponse> = {
  encode(message: PeerManifestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.peerManifests) {
      PeerManifest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeerManifestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeerManifestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerManifests.push(PeerManifest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeerManifestsResponse {
    return {
      peerManifests: globalThis.Array.isArray(object?.peerManifests)
        ? object.peerManifests.map((e: any) => PeerManifest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PeerManifestsResponse): unknown {
    const obj: any = {};
    if (message.peerManifests?.length) {
      obj.peerManifests = message.peerManifests.map((e) => PeerManifest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeerManifestsResponse>, I>>(base?: I): PeerManifestsResponse {
    return PeerManifestsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeerManifestsResponse>, I>>(object: I): PeerManifestsResponse {
    const message = createBasePeerManifestsResponse();
    message.peerManifests = object.peerManifests?.map((e) => PeerManifest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAcceptPendingTransactionRequest(): AcceptPendingTransactionRequest {
  return { pendingTransaction: undefined, signature: undefined };
}

export const AcceptPendingTransactionRequest: MessageFns<AcceptPendingTransactionRequest> = {
  encode(message: AcceptPendingTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pendingTransaction !== undefined) {
      PendingTransactionRef.encode(message.pendingTransaction, writer.uint32(10).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceptPendingTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceptPendingTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pendingTransaction = PendingTransactionRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceptPendingTransactionRequest {
    return {
      pendingTransaction: isSet(object.pendingTransaction)
        ? PendingTransactionRef.fromJSON(object.pendingTransaction)
        : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: AcceptPendingTransactionRequest): unknown {
    const obj: any = {};
    if (message.pendingTransaction !== undefined) {
      obj.pendingTransaction = PendingTransactionRef.toJSON(message.pendingTransaction);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AcceptPendingTransactionRequest>, I>>(base?: I): AcceptPendingTransactionRequest {
    return AcceptPendingTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AcceptPendingTransactionRequest>, I>>(
    object: I,
  ): AcceptPendingTransactionRequest {
    const message = createBaseAcceptPendingTransactionRequest();
    message.pendingTransaction = (object.pendingTransaction !== undefined && object.pendingTransaction !== null)
      ? PendingTransactionRef.fromPartial(object.pendingTransaction)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseAllowAccountRequest(): AllowAccountRequest {
  return {
    ofAccount: undefined,
    permittedAccount: undefined,
    permittedOperations: [],
    allowance: undefined,
    signature: undefined,
  };
}

export const AllowAccountRequest: MessageFns<AllowAccountRequest> = {
  encode(message: AllowAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ofAccount !== undefined) {
      AccountRef.encode(message.ofAccount, writer.uint32(10).fork()).join();
    }
    if (message.permittedAccount !== undefined) {
      AccountRef.encode(message.permittedAccount, writer.uint32(18).fork()).join();
    }
    for (const v of message.permittedOperations) {
      writer.uint32(26).string(v!);
    }
    if (message.allowance !== undefined) {
      AccountAllowanceRef.encode(message.allowance, writer.uint32(34).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ofAccount = AccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permittedAccount = AccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.permittedOperations.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.allowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowAccountRequest {
    return {
      ofAccount: isSet(object.ofAccount) ? AccountRef.fromJSON(object.ofAccount) : undefined,
      permittedAccount: isSet(object.permittedAccount) ? AccountRef.fromJSON(object.permittedAccount) : undefined,
      permittedOperations: globalThis.Array.isArray(object?.permittedOperations)
        ? object.permittedOperations.map((e: any) => globalThis.String(e))
        : [],
      allowance: isSet(object.allowance) ? AccountAllowanceRef.fromJSON(object.allowance) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: AllowAccountRequest): unknown {
    const obj: any = {};
    if (message.ofAccount !== undefined) {
      obj.ofAccount = AccountRef.toJSON(message.ofAccount);
    }
    if (message.permittedAccount !== undefined) {
      obj.permittedAccount = AccountRef.toJSON(message.permittedAccount);
    }
    if (message.permittedOperations?.length) {
      obj.permittedOperations = message.permittedOperations;
    }
    if (message.allowance !== undefined) {
      obj.allowance = AccountAllowanceRef.toJSON(message.allowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowAccountRequest>, I>>(base?: I): AllowAccountRequest {
    return AllowAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowAccountRequest>, I>>(object: I): AllowAccountRequest {
    const message = createBaseAllowAccountRequest();
    message.ofAccount = (object.ofAccount !== undefined && object.ofAccount !== null)
      ? AccountRef.fromPartial(object.ofAccount)
      : undefined;
    message.permittedAccount = (object.permittedAccount !== undefined && object.permittedAccount !== null)
      ? AccountRef.fromPartial(object.permittedAccount)
      : undefined;
    message.permittedOperations = object.permittedOperations?.map((e) => e) || [];
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? AccountAllowanceRef.fromPartial(object.allowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseAllowCoinRequest(): AllowCoinRequest {
  return {
    ofCoin: undefined,
    permittedAccount: undefined,
    permittedOperations: [],
    accountAllowance: undefined,
    coinAllowance: undefined,
    signature: undefined,
  };
}

export const AllowCoinRequest: MessageFns<AllowCoinRequest> = {
  encode(message: AllowCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ofCoin !== undefined) {
      CoinRef.encode(message.ofCoin, writer.uint32(10).fork()).join();
    }
    if (message.permittedAccount !== undefined) {
      AccountRef.encode(message.permittedAccount, writer.uint32(18).fork()).join();
    }
    for (const v of message.permittedOperations) {
      writer.uint32(26).string(v!);
    }
    if (message.accountAllowance !== undefined) {
      AccountAllowanceRef.encode(message.accountAllowance, writer.uint32(34).fork()).join();
    }
    if (message.coinAllowance !== undefined) {
      CoinAllowanceRef.encode(message.coinAllowance, writer.uint32(42).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ofCoin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permittedAccount = AccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.permittedOperations.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accountAllowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.coinAllowance = CoinAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowCoinRequest {
    return {
      ofCoin: isSet(object.ofCoin) ? CoinRef.fromJSON(object.ofCoin) : undefined,
      permittedAccount: isSet(object.permittedAccount) ? AccountRef.fromJSON(object.permittedAccount) : undefined,
      permittedOperations: globalThis.Array.isArray(object?.permittedOperations)
        ? object.permittedOperations.map((e: any) => globalThis.String(e))
        : [],
      accountAllowance: isSet(object.accountAllowance)
        ? AccountAllowanceRef.fromJSON(object.accountAllowance)
        : undefined,
      coinAllowance: isSet(object.coinAllowance) ? CoinAllowanceRef.fromJSON(object.coinAllowance) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: AllowCoinRequest): unknown {
    const obj: any = {};
    if (message.ofCoin !== undefined) {
      obj.ofCoin = CoinRef.toJSON(message.ofCoin);
    }
    if (message.permittedAccount !== undefined) {
      obj.permittedAccount = AccountRef.toJSON(message.permittedAccount);
    }
    if (message.permittedOperations?.length) {
      obj.permittedOperations = message.permittedOperations;
    }
    if (message.accountAllowance !== undefined) {
      obj.accountAllowance = AccountAllowanceRef.toJSON(message.accountAllowance);
    }
    if (message.coinAllowance !== undefined) {
      obj.coinAllowance = CoinAllowanceRef.toJSON(message.coinAllowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowCoinRequest>, I>>(base?: I): AllowCoinRequest {
    return AllowCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowCoinRequest>, I>>(object: I): AllowCoinRequest {
    const message = createBaseAllowCoinRequest();
    message.ofCoin = (object.ofCoin !== undefined && object.ofCoin !== null)
      ? CoinRef.fromPartial(object.ofCoin)
      : undefined;
    message.permittedAccount = (object.permittedAccount !== undefined && object.permittedAccount !== null)
      ? AccountRef.fromPartial(object.permittedAccount)
      : undefined;
    message.permittedOperations = object.permittedOperations?.map((e) => e) || [];
    message.accountAllowance = (object.accountAllowance !== undefined && object.accountAllowance !== null)
      ? AccountAllowanceRef.fromPartial(object.accountAllowance)
      : undefined;
    message.coinAllowance = (object.coinAllowance !== undefined && object.coinAllowance !== null)
      ? CoinAllowanceRef.fromPartial(object.coinAllowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseBalanceAccountRequest(): BalanceAccountRequest {
  return { account: undefined, allowance: undefined, signature: undefined };
}

export const BalanceAccountRequest: MessageFns<BalanceAccountRequest> = {
  encode(message: BalanceAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== undefined) {
      AccountRef.encode(message.account, writer.uint32(10).fork()).join();
    }
    if (message.allowance !== undefined) {
      AccountAllowanceRef.encode(message.allowance, writer.uint32(18).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = AccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceAccountRequest {
    return {
      account: isSet(object.account) ? AccountRef.fromJSON(object.account) : undefined,
      allowance: isSet(object.allowance) ? AccountAllowanceRef.fromJSON(object.allowance) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: BalanceAccountRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountRef.toJSON(message.account);
    }
    if (message.allowance !== undefined) {
      obj.allowance = AccountAllowanceRef.toJSON(message.allowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceAccountRequest>, I>>(base?: I): BalanceAccountRequest {
    return BalanceAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceAccountRequest>, I>>(object: I): BalanceAccountRequest {
    const message = createBaseBalanceAccountRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountRef.fromPartial(object.account)
      : undefined;
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? AccountAllowanceRef.fromPartial(object.allowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseCoinsAccountRequest(): CoinsAccountRequest {
  return { account: undefined, allowance: undefined, signature: undefined };
}

export const CoinsAccountRequest: MessageFns<CoinsAccountRequest> = {
  encode(message: CoinsAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== undefined) {
      AccountRef.encode(message.account, writer.uint32(10).fork()).join();
    }
    if (message.allowance !== undefined) {
      AccountAllowanceRef.encode(message.allowance, writer.uint32(18).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoinsAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinsAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = AccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoinsAccountRequest {
    return {
      account: isSet(object.account) ? AccountRef.fromJSON(object.account) : undefined,
      allowance: isSet(object.allowance) ? AccountAllowanceRef.fromJSON(object.allowance) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: CoinsAccountRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountRef.toJSON(message.account);
    }
    if (message.allowance !== undefined) {
      obj.allowance = AccountAllowanceRef.toJSON(message.allowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoinsAccountRequest>, I>>(base?: I): CoinsAccountRequest {
    return CoinsAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoinsAccountRequest>, I>>(object: I): CoinsAccountRequest {
    const message = createBaseCoinsAccountRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountRef.fromPartial(object.account)
      : undefined;
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? AccountAllowanceRef.fromPartial(object.allowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBasePendingTransactionsAccountRequest(): PendingTransactionsAccountRequest {
  return { account: undefined, allowance: undefined, signature: undefined };
}

export const PendingTransactionsAccountRequest: MessageFns<PendingTransactionsAccountRequest> = {
  encode(message: PendingTransactionsAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== undefined) {
      AccountRef.encode(message.account, writer.uint32(10).fork()).join();
    }
    if (message.allowance !== undefined) {
      AccountAllowanceRef.encode(message.allowance, writer.uint32(18).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingTransactionsAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingTransactionsAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = AccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingTransactionsAccountRequest {
    return {
      account: isSet(object.account) ? AccountRef.fromJSON(object.account) : undefined,
      allowance: isSet(object.allowance) ? AccountAllowanceRef.fromJSON(object.allowance) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: PendingTransactionsAccountRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountRef.toJSON(message.account);
    }
    if (message.allowance !== undefined) {
      obj.allowance = AccountAllowanceRef.toJSON(message.allowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingTransactionsAccountRequest>, I>>(
    base?: I,
  ): PendingTransactionsAccountRequest {
    return PendingTransactionsAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingTransactionsAccountRequest>, I>>(
    object: I,
  ): PendingTransactionsAccountRequest {
    const message = createBasePendingTransactionsAccountRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountRef.fromPartial(object.account)
      : undefined;
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? AccountAllowanceRef.fromPartial(object.allowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseIntersectCoinRequest(): IntersectCoinRequest {
  return { addresses: [], accountAllowance: undefined, coinAllowance: undefined, ofCoin: undefined };
}

export const IntersectCoinRequest: MessageFns<IntersectCoinRequest> = {
  encode(message: IntersectCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      writer.uint32(10).bytes(v!);
    }
    if (message.accountAllowance !== undefined) {
      AccountAllowanceRef.encode(message.accountAllowance, writer.uint32(18).fork()).join();
    }
    if (message.coinAllowance !== undefined) {
      CoinAllowanceRef.encode(message.coinAllowance, writer.uint32(26).fork()).join();
    }
    if (message.ofCoin !== undefined) {
      CoinRef.encode(message.ofCoin, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntersectCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntersectCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAllowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.coinAllowance = CoinAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ofCoin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntersectCoinRequest {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => bytesFromBase64(e))
        : [],
      accountAllowance: isSet(object.accountAllowance)
        ? AccountAllowanceRef.fromJSON(object.accountAllowance)
        : undefined,
      coinAllowance: isSet(object.coinAllowance) ? CoinAllowanceRef.fromJSON(object.coinAllowance) : undefined,
      ofCoin: isSet(object.ofCoin) ? CoinRef.fromJSON(object.ofCoin) : undefined,
    };
  },

  toJSON(message: IntersectCoinRequest): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => base64FromBytes(e));
    }
    if (message.accountAllowance !== undefined) {
      obj.accountAllowance = AccountAllowanceRef.toJSON(message.accountAllowance);
    }
    if (message.coinAllowance !== undefined) {
      obj.coinAllowance = CoinAllowanceRef.toJSON(message.coinAllowance);
    }
    if (message.ofCoin !== undefined) {
      obj.ofCoin = CoinRef.toJSON(message.ofCoin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntersectCoinRequest>, I>>(base?: I): IntersectCoinRequest {
    return IntersectCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntersectCoinRequest>, I>>(object: I): IntersectCoinRequest {
    const message = createBaseIntersectCoinRequest();
    message.addresses = object.addresses?.map((e) => e) || [];
    message.accountAllowance = (object.accountAllowance !== undefined && object.accountAllowance !== null)
      ? AccountAllowanceRef.fromPartial(object.accountAllowance)
      : undefined;
    message.coinAllowance = (object.coinAllowance !== undefined && object.coinAllowance !== null)
      ? CoinAllowanceRef.fromPartial(object.coinAllowance)
      : undefined;
    message.ofCoin = (object.ofCoin !== undefined && object.ofCoin !== null)
      ? CoinRef.fromPartial(object.ofCoin)
      : undefined;
    return message;
  },
};

function createBaseMergeCoinRequest(): MergeCoinRequest {
  return { coins: [], accountAllowance: undefined, coinAllowances: [], signature: undefined };
}

export const MergeCoinRequest: MessageFns<MergeCoinRequest> = {
  encode(message: MergeCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.coins) {
      CoinRef.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.accountAllowance !== undefined) {
      AccountAllowanceRef.encode(message.accountAllowance, writer.uint32(18).fork()).join();
    }
    for (const v of message.coinAllowances) {
      CoinAllowanceRef.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.signature !== undefined) {
      Ed448Signature.encode(message.signature, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coins.push(CoinRef.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAllowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.coinAllowances.push(CoinAllowanceRef.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signature = Ed448Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeCoinRequest {
    return {
      coins: globalThis.Array.isArray(object?.coins) ? object.coins.map((e: any) => CoinRef.fromJSON(e)) : [],
      accountAllowance: isSet(object.accountAllowance)
        ? AccountAllowanceRef.fromJSON(object.accountAllowance)
        : undefined,
      coinAllowances: globalThis.Array.isArray(object?.coinAllowances)
        ? object.coinAllowances.map((e: any) => CoinAllowanceRef.fromJSON(e))
        : [],
      signature: isSet(object.signature) ? Ed448Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: MergeCoinRequest): unknown {
    const obj: any = {};
    if (message.coins?.length) {
      obj.coins = message.coins.map((e) => CoinRef.toJSON(e));
    }
    if (message.accountAllowance !== undefined) {
      obj.accountAllowance = AccountAllowanceRef.toJSON(message.accountAllowance);
    }
    if (message.coinAllowances?.length) {
      obj.coinAllowances = message.coinAllowances.map((e) => CoinAllowanceRef.toJSON(e));
    }
    if (message.signature !== undefined) {
      obj.signature = Ed448Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MergeCoinRequest>, I>>(base?: I): MergeCoinRequest {
    return MergeCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MergeCoinRequest>, I>>(object: I): MergeCoinRequest {
    const message = createBaseMergeCoinRequest();
    message.coins = object.coins?.map((e) => CoinRef.fromPartial(e)) || [];
    message.accountAllowance = (object.accountAllowance !== undefined && object.accountAllowance !== null)
      ? AccountAllowanceRef.fromPartial(object.accountAllowance)
      : undefined;
    message.coinAllowances = object.coinAllowances?.map((e) => CoinAllowanceRef.fromPartial(e)) || [];
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Ed448Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseMintCoinRequest(): MintCoinRequest {
  return { proofs: [], allowance: undefined, signature: undefined };
}

export const MintCoinRequest: MessageFns<MintCoinRequest> = {
  encode(message: MintCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.proofs) {
      writer.uint32(10).bytes(v!);
    }
    if (message.allowance !== undefined) {
      AccountAllowanceRef.encode(message.allowance, writer.uint32(18).fork()).join();
    }
    if (message.signature !== undefined) {
      Ed448Signature.encode(message.signature, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MintCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofs.push(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = Ed448Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintCoinRequest {
    return {
      proofs: globalThis.Array.isArray(object?.proofs) ? object.proofs.map((e: any) => bytesFromBase64(e)) : [],
      allowance: isSet(object.allowance) ? AccountAllowanceRef.fromJSON(object.allowance) : undefined,
      signature: isSet(object.signature) ? Ed448Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: MintCoinRequest): unknown {
    const obj: any = {};
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => base64FromBytes(e));
    }
    if (message.allowance !== undefined) {
      obj.allowance = AccountAllowanceRef.toJSON(message.allowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Ed448Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MintCoinRequest>, I>>(base?: I): MintCoinRequest {
    return MintCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MintCoinRequest>, I>>(object: I): MintCoinRequest {
    const message = createBaseMintCoinRequest();
    message.proofs = object.proofs?.map((e) => e) || [];
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? AccountAllowanceRef.fromPartial(object.allowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Ed448Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseMutualReceiveCoinRequest(): MutualReceiveCoinRequest {
  return { toAccount: undefined, allowance: undefined, signature: undefined };
}

export const MutualReceiveCoinRequest: MessageFns<MutualReceiveCoinRequest> = {
  encode(message: MutualReceiveCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toAccount !== undefined) {
      AccountRef.encode(message.toAccount, writer.uint32(10).fork()).join();
    }
    if (message.allowance !== undefined) {
      AccountAllowanceRef.encode(message.allowance, writer.uint32(18).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutualReceiveCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutualReceiveCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toAccount = AccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutualReceiveCoinRequest {
    return {
      toAccount: isSet(object.toAccount) ? AccountRef.fromJSON(object.toAccount) : undefined,
      allowance: isSet(object.allowance) ? AccountAllowanceRef.fromJSON(object.allowance) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: MutualReceiveCoinRequest): unknown {
    const obj: any = {};
    if (message.toAccount !== undefined) {
      obj.toAccount = AccountRef.toJSON(message.toAccount);
    }
    if (message.allowance !== undefined) {
      obj.allowance = AccountAllowanceRef.toJSON(message.allowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutualReceiveCoinRequest>, I>>(base?: I): MutualReceiveCoinRequest {
    return MutualReceiveCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutualReceiveCoinRequest>, I>>(object: I): MutualReceiveCoinRequest {
    const message = createBaseMutualReceiveCoinRequest();
    message.toAccount = (object.toAccount !== undefined && object.toAccount !== null)
      ? AccountRef.fromPartial(object.toAccount)
      : undefined;
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? AccountAllowanceRef.fromPartial(object.allowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseMutualTransferCoinRequest(): MutualTransferCoinRequest {
  return {
    rendezvous: new Uint8Array(0),
    ofCoin: undefined,
    accountAllowance: undefined,
    coinAllowance: undefined,
    signature: undefined,
  };
}

export const MutualTransferCoinRequest: MessageFns<MutualTransferCoinRequest> = {
  encode(message: MutualTransferCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rendezvous.length !== 0) {
      writer.uint32(10).bytes(message.rendezvous);
    }
    if (message.ofCoin !== undefined) {
      CoinRef.encode(message.ofCoin, writer.uint32(18).fork()).join();
    }
    if (message.accountAllowance !== undefined) {
      AccountAllowanceRef.encode(message.accountAllowance, writer.uint32(26).fork()).join();
    }
    if (message.coinAllowance !== undefined) {
      CoinAllowanceRef.encode(message.coinAllowance, writer.uint32(34).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutualTransferCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutualTransferCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rendezvous = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ofCoin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accountAllowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.coinAllowance = CoinAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutualTransferCoinRequest {
    return {
      rendezvous: isSet(object.rendezvous) ? bytesFromBase64(object.rendezvous) : new Uint8Array(0),
      ofCoin: isSet(object.ofCoin) ? CoinRef.fromJSON(object.ofCoin) : undefined,
      accountAllowance: isSet(object.accountAllowance)
        ? AccountAllowanceRef.fromJSON(object.accountAllowance)
        : undefined,
      coinAllowance: isSet(object.coinAllowance) ? CoinAllowanceRef.fromJSON(object.coinAllowance) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: MutualTransferCoinRequest): unknown {
    const obj: any = {};
    if (message.rendezvous.length !== 0) {
      obj.rendezvous = base64FromBytes(message.rendezvous);
    }
    if (message.ofCoin !== undefined) {
      obj.ofCoin = CoinRef.toJSON(message.ofCoin);
    }
    if (message.accountAllowance !== undefined) {
      obj.accountAllowance = AccountAllowanceRef.toJSON(message.accountAllowance);
    }
    if (message.coinAllowance !== undefined) {
      obj.coinAllowance = CoinAllowanceRef.toJSON(message.coinAllowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutualTransferCoinRequest>, I>>(base?: I): MutualTransferCoinRequest {
    return MutualTransferCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutualTransferCoinRequest>, I>>(object: I): MutualTransferCoinRequest {
    const message = createBaseMutualTransferCoinRequest();
    message.rendezvous = object.rendezvous ?? new Uint8Array(0);
    message.ofCoin = (object.ofCoin !== undefined && object.ofCoin !== null)
      ? CoinRef.fromPartial(object.ofCoin)
      : undefined;
    message.accountAllowance = (object.accountAllowance !== undefined && object.accountAllowance !== null)
      ? AccountAllowanceRef.fromPartial(object.accountAllowance)
      : undefined;
    message.coinAllowance = (object.coinAllowance !== undefined && object.coinAllowance !== null)
      ? CoinAllowanceRef.fromPartial(object.coinAllowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseRevokeAccountRequest(): RevokeAccountRequest {
  return { ofAccount: undefined, revokedAllowance: undefined, allowance: undefined, signature: undefined };
}

export const RevokeAccountRequest: MessageFns<RevokeAccountRequest> = {
  encode(message: RevokeAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ofAccount !== undefined) {
      AccountRef.encode(message.ofAccount, writer.uint32(10).fork()).join();
    }
    if (message.revokedAllowance !== undefined) {
      AccountAllowanceRef.encode(message.revokedAllowance, writer.uint32(18).fork()).join();
    }
    if (message.allowance !== undefined) {
      AccountAllowanceRef.encode(message.allowance, writer.uint32(26).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ofAccount = AccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.revokedAllowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeAccountRequest {
    return {
      ofAccount: isSet(object.ofAccount) ? AccountRef.fromJSON(object.ofAccount) : undefined,
      revokedAllowance: isSet(object.revokedAllowance)
        ? AccountAllowanceRef.fromJSON(object.revokedAllowance)
        : undefined,
      allowance: isSet(object.allowance) ? AccountAllowanceRef.fromJSON(object.allowance) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: RevokeAccountRequest): unknown {
    const obj: any = {};
    if (message.ofAccount !== undefined) {
      obj.ofAccount = AccountRef.toJSON(message.ofAccount);
    }
    if (message.revokedAllowance !== undefined) {
      obj.revokedAllowance = AccountAllowanceRef.toJSON(message.revokedAllowance);
    }
    if (message.allowance !== undefined) {
      obj.allowance = AccountAllowanceRef.toJSON(message.allowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeAccountRequest>, I>>(base?: I): RevokeAccountRequest {
    return RevokeAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeAccountRequest>, I>>(object: I): RevokeAccountRequest {
    const message = createBaseRevokeAccountRequest();
    message.ofAccount = (object.ofAccount !== undefined && object.ofAccount !== null)
      ? AccountRef.fromPartial(object.ofAccount)
      : undefined;
    message.revokedAllowance = (object.revokedAllowance !== undefined && object.revokedAllowance !== null)
      ? AccountAllowanceRef.fromPartial(object.revokedAllowance)
      : undefined;
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? AccountAllowanceRef.fromPartial(object.allowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseRevokeCoinRequest(): RevokeCoinRequest {
  return {
    ofCoin: undefined,
    revokedAllowance: undefined,
    accountAllowance: undefined,
    coinAllowance: undefined,
    signature: undefined,
  };
}

export const RevokeCoinRequest: MessageFns<RevokeCoinRequest> = {
  encode(message: RevokeCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ofCoin !== undefined) {
      CoinRef.encode(message.ofCoin, writer.uint32(10).fork()).join();
    }
    if (message.revokedAllowance !== undefined) {
      CoinAllowanceRef.encode(message.revokedAllowance, writer.uint32(18).fork()).join();
    }
    if (message.accountAllowance !== undefined) {
      AccountAllowanceRef.encode(message.accountAllowance, writer.uint32(26).fork()).join();
    }
    if (message.coinAllowance !== undefined) {
      CoinAllowanceRef.encode(message.coinAllowance, writer.uint32(34).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ofCoin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.revokedAllowance = CoinAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accountAllowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.coinAllowance = CoinAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeCoinRequest {
    return {
      ofCoin: isSet(object.ofCoin) ? CoinRef.fromJSON(object.ofCoin) : undefined,
      revokedAllowance: isSet(object.revokedAllowance) ? CoinAllowanceRef.fromJSON(object.revokedAllowance) : undefined,
      accountAllowance: isSet(object.accountAllowance)
        ? AccountAllowanceRef.fromJSON(object.accountAllowance)
        : undefined,
      coinAllowance: isSet(object.coinAllowance) ? CoinAllowanceRef.fromJSON(object.coinAllowance) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: RevokeCoinRequest): unknown {
    const obj: any = {};
    if (message.ofCoin !== undefined) {
      obj.ofCoin = CoinRef.toJSON(message.ofCoin);
    }
    if (message.revokedAllowance !== undefined) {
      obj.revokedAllowance = CoinAllowanceRef.toJSON(message.revokedAllowance);
    }
    if (message.accountAllowance !== undefined) {
      obj.accountAllowance = AccountAllowanceRef.toJSON(message.accountAllowance);
    }
    if (message.coinAllowance !== undefined) {
      obj.coinAllowance = CoinAllowanceRef.toJSON(message.coinAllowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeCoinRequest>, I>>(base?: I): RevokeCoinRequest {
    return RevokeCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeCoinRequest>, I>>(object: I): RevokeCoinRequest {
    const message = createBaseRevokeCoinRequest();
    message.ofCoin = (object.ofCoin !== undefined && object.ofCoin !== null)
      ? CoinRef.fromPartial(object.ofCoin)
      : undefined;
    message.revokedAllowance = (object.revokedAllowance !== undefined && object.revokedAllowance !== null)
      ? CoinAllowanceRef.fromPartial(object.revokedAllowance)
      : undefined;
    message.accountAllowance = (object.accountAllowance !== undefined && object.accountAllowance !== null)
      ? AccountAllowanceRef.fromPartial(object.accountAllowance)
      : undefined;
    message.coinAllowance = (object.coinAllowance !== undefined && object.coinAllowance !== null)
      ? CoinAllowanceRef.fromPartial(object.coinAllowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseSplitCoinRequest(): SplitCoinRequest {
  return {
    ofCoin: undefined,
    amounts: [],
    accountAllowance: undefined,
    coinAllowance: undefined,
    signature: undefined,
  };
}

export const SplitCoinRequest: MessageFns<SplitCoinRequest> = {
  encode(message: SplitCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ofCoin !== undefined) {
      CoinRef.encode(message.ofCoin, writer.uint32(10).fork()).join();
    }
    for (const v of message.amounts) {
      writer.uint32(18).bytes(v!);
    }
    if (message.accountAllowance !== undefined) {
      AccountAllowanceRef.encode(message.accountAllowance, writer.uint32(26).fork()).join();
    }
    if (message.coinAllowance !== undefined) {
      CoinAllowanceRef.encode(message.coinAllowance, writer.uint32(34).fork()).join();
    }
    if (message.signature !== undefined) {
      Ed448Signature.encode(message.signature, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplitCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplitCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ofCoin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amounts.push(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accountAllowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.coinAllowance = CoinAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = Ed448Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplitCoinRequest {
    return {
      ofCoin: isSet(object.ofCoin) ? CoinRef.fromJSON(object.ofCoin) : undefined,
      amounts: globalThis.Array.isArray(object?.amounts) ? object.amounts.map((e: any) => bytesFromBase64(e)) : [],
      accountAllowance: isSet(object.accountAllowance)
        ? AccountAllowanceRef.fromJSON(object.accountAllowance)
        : undefined,
      coinAllowance: isSet(object.coinAllowance) ? CoinAllowanceRef.fromJSON(object.coinAllowance) : undefined,
      signature: isSet(object.signature) ? Ed448Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: SplitCoinRequest): unknown {
    const obj: any = {};
    if (message.ofCoin !== undefined) {
      obj.ofCoin = CoinRef.toJSON(message.ofCoin);
    }
    if (message.amounts?.length) {
      obj.amounts = message.amounts.map((e) => base64FromBytes(e));
    }
    if (message.accountAllowance !== undefined) {
      obj.accountAllowance = AccountAllowanceRef.toJSON(message.accountAllowance);
    }
    if (message.coinAllowance !== undefined) {
      obj.coinAllowance = CoinAllowanceRef.toJSON(message.coinAllowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Ed448Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SplitCoinRequest>, I>>(base?: I): SplitCoinRequest {
    return SplitCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SplitCoinRequest>, I>>(object: I): SplitCoinRequest {
    const message = createBaseSplitCoinRequest();
    message.ofCoin = (object.ofCoin !== undefined && object.ofCoin !== null)
      ? CoinRef.fromPartial(object.ofCoin)
      : undefined;
    message.amounts = object.amounts?.map((e) => e) || [];
    message.accountAllowance = (object.accountAllowance !== undefined && object.accountAllowance !== null)
      ? AccountAllowanceRef.fromPartial(object.accountAllowance)
      : undefined;
    message.coinAllowance = (object.coinAllowance !== undefined && object.coinAllowance !== null)
      ? CoinAllowanceRef.fromPartial(object.coinAllowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Ed448Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseTransferCoinRequest(): TransferCoinRequest {
  return {
    toAccount: undefined,
    refundAccount: undefined,
    ofCoin: undefined,
    expiry: Long.ZERO,
    accountAllowance: undefined,
    coinAllowance: undefined,
    signature: undefined,
  };
}

export const TransferCoinRequest: MessageFns<TransferCoinRequest> = {
  encode(message: TransferCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toAccount !== undefined) {
      AccountRef.encode(message.toAccount, writer.uint32(10).fork()).join();
    }
    if (message.refundAccount !== undefined) {
      AccountRef.encode(message.refundAccount, writer.uint32(18).fork()).join();
    }
    if (message.ofCoin !== undefined) {
      CoinRef.encode(message.ofCoin, writer.uint32(26).fork()).join();
    }
    if (!message.expiry.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.expiry.toString());
    }
    if (message.accountAllowance !== undefined) {
      AccountAllowanceRef.encode(message.accountAllowance, writer.uint32(42).fork()).join();
    }
    if (message.coinAllowance !== undefined) {
      CoinAllowanceRef.encode(message.coinAllowance, writer.uint32(50).fork()).join();
    }
    if (message.signature !== undefined) {
      Ed448Signature.encode(message.signature, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toAccount = AccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundAccount = AccountRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ofCoin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiry = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.accountAllowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.coinAllowance = CoinAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.signature = Ed448Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferCoinRequest {
    return {
      toAccount: isSet(object.toAccount) ? AccountRef.fromJSON(object.toAccount) : undefined,
      refundAccount: isSet(object.refundAccount) ? AccountRef.fromJSON(object.refundAccount) : undefined,
      ofCoin: isSet(object.ofCoin) ? CoinRef.fromJSON(object.ofCoin) : undefined,
      expiry: isSet(object.expiry) ? Long.fromValue(object.expiry) : Long.ZERO,
      accountAllowance: isSet(object.accountAllowance)
        ? AccountAllowanceRef.fromJSON(object.accountAllowance)
        : undefined,
      coinAllowance: isSet(object.coinAllowance) ? CoinAllowanceRef.fromJSON(object.coinAllowance) : undefined,
      signature: isSet(object.signature) ? Ed448Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: TransferCoinRequest): unknown {
    const obj: any = {};
    if (message.toAccount !== undefined) {
      obj.toAccount = AccountRef.toJSON(message.toAccount);
    }
    if (message.refundAccount !== undefined) {
      obj.refundAccount = AccountRef.toJSON(message.refundAccount);
    }
    if (message.ofCoin !== undefined) {
      obj.ofCoin = CoinRef.toJSON(message.ofCoin);
    }
    if (!message.expiry.equals(Long.ZERO)) {
      obj.expiry = (message.expiry || Long.ZERO).toString();
    }
    if (message.accountAllowance !== undefined) {
      obj.accountAllowance = AccountAllowanceRef.toJSON(message.accountAllowance);
    }
    if (message.coinAllowance !== undefined) {
      obj.coinAllowance = CoinAllowanceRef.toJSON(message.coinAllowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Ed448Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferCoinRequest>, I>>(base?: I): TransferCoinRequest {
    return TransferCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferCoinRequest>, I>>(object: I): TransferCoinRequest {
    const message = createBaseTransferCoinRequest();
    message.toAccount = (object.toAccount !== undefined && object.toAccount !== null)
      ? AccountRef.fromPartial(object.toAccount)
      : undefined;
    message.refundAccount = (object.refundAccount !== undefined && object.refundAccount !== null)
      ? AccountRef.fromPartial(object.refundAccount)
      : undefined;
    message.ofCoin = (object.ofCoin !== undefined && object.ofCoin !== null)
      ? CoinRef.fromPartial(object.ofCoin)
      : undefined;
    message.expiry = (object.expiry !== undefined && object.expiry !== null)
      ? Long.fromValue(object.expiry)
      : Long.ZERO;
    message.accountAllowance = (object.accountAllowance !== undefined && object.accountAllowance !== null)
      ? AccountAllowanceRef.fromPartial(object.accountAllowance)
      : undefined;
    message.coinAllowance = (object.coinAllowance !== undefined && object.coinAllowance !== null)
      ? CoinAllowanceRef.fromPartial(object.coinAllowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Ed448Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseApprovePendingTransactionRequest(): ApprovePendingTransactionRequest {
  return { pendingTransaction: undefined, accountAllowance: undefined, signature: undefined };
}

export const ApprovePendingTransactionRequest: MessageFns<ApprovePendingTransactionRequest> = {
  encode(message: ApprovePendingTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pendingTransaction !== undefined) {
      PendingTransactionRef.encode(message.pendingTransaction, writer.uint32(10).fork()).join();
    }
    if (message.accountAllowance !== undefined) {
      AccountAllowanceRef.encode(message.accountAllowance, writer.uint32(18).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApprovePendingTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApprovePendingTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pendingTransaction = PendingTransactionRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAllowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApprovePendingTransactionRequest {
    return {
      pendingTransaction: isSet(object.pendingTransaction)
        ? PendingTransactionRef.fromJSON(object.pendingTransaction)
        : undefined,
      accountAllowance: isSet(object.accountAllowance)
        ? AccountAllowanceRef.fromJSON(object.accountAllowance)
        : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: ApprovePendingTransactionRequest): unknown {
    const obj: any = {};
    if (message.pendingTransaction !== undefined) {
      obj.pendingTransaction = PendingTransactionRef.toJSON(message.pendingTransaction);
    }
    if (message.accountAllowance !== undefined) {
      obj.accountAllowance = AccountAllowanceRef.toJSON(message.accountAllowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApprovePendingTransactionRequest>, I>>(
    base?: I,
  ): ApprovePendingTransactionRequest {
    return ApprovePendingTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApprovePendingTransactionRequest>, I>>(
    object: I,
  ): ApprovePendingTransactionRequest {
    const message = createBaseApprovePendingTransactionRequest();
    message.pendingTransaction = (object.pendingTransaction !== undefined && object.pendingTransaction !== null)
      ? PendingTransactionRef.fromPartial(object.pendingTransaction)
      : undefined;
    message.accountAllowance = (object.accountAllowance !== undefined && object.accountAllowance !== null)
      ? AccountAllowanceRef.fromPartial(object.accountAllowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseRejectPendingTransactionRequest(): RejectPendingTransactionRequest {
  return { pendingTransaction: undefined, accountAllowance: undefined, signature: undefined };
}

export const RejectPendingTransactionRequest: MessageFns<RejectPendingTransactionRequest> = {
  encode(message: RejectPendingTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pendingTransaction !== undefined) {
      PendingTransactionRef.encode(message.pendingTransaction, writer.uint32(10).fork()).join();
    }
    if (message.accountAllowance !== undefined) {
      AccountAllowanceRef.encode(message.accountAllowance, writer.uint32(18).fork()).join();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RejectPendingTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectPendingTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pendingTransaction = PendingTransactionRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAllowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RejectPendingTransactionRequest {
    return {
      pendingTransaction: isSet(object.pendingTransaction)
        ? PendingTransactionRef.fromJSON(object.pendingTransaction)
        : undefined,
      accountAllowance: isSet(object.accountAllowance)
        ? AccountAllowanceRef.fromJSON(object.accountAllowance)
        : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: RejectPendingTransactionRequest): unknown {
    const obj: any = {};
    if (message.pendingTransaction !== undefined) {
      obj.pendingTransaction = PendingTransactionRef.toJSON(message.pendingTransaction);
    }
    if (message.accountAllowance !== undefined) {
      obj.accountAllowance = AccountAllowanceRef.toJSON(message.accountAllowance);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RejectPendingTransactionRequest>, I>>(base?: I): RejectPendingTransactionRequest {
    return RejectPendingTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RejectPendingTransactionRequest>, I>>(
    object: I,
  ): RejectPendingTransactionRequest {
    const message = createBaseRejectPendingTransactionRequest();
    message.pendingTransaction = (object.pendingTransaction !== undefined && object.pendingTransaction !== null)
      ? PendingTransactionRef.fromPartial(object.pendingTransaction)
      : undefined;
    message.accountAllowance = (object.accountAllowance !== undefined && object.accountAllowance !== null)
      ? AccountAllowanceRef.fromPartial(object.accountAllowance)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseInlineKey(): InlineKey {
  return { ref: new Uint8Array(0), key: new Uint8Array(0) };
}

export const InlineKey: MessageFns<InlineKey> = {
  encode(message: InlineKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ref.length !== 0) {
      writer.uint32(10).bytes(message.ref);
    }
    if (message.key.length !== 0) {
      writer.uint32(18).bytes(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InlineKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInlineKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ref = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InlineKey {
    return {
      ref: isSet(object.ref) ? bytesFromBase64(object.ref) : new Uint8Array(0),
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
    };
  },

  toJSON(message: InlineKey): unknown {
    const obj: any = {};
    if (message.ref.length !== 0) {
      obj.ref = base64FromBytes(message.ref);
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InlineKey>, I>>(base?: I): InlineKey {
    return InlineKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InlineKey>, I>>(object: I): InlineKey {
    const message = createBaseInlineKey();
    message.ref = object.ref ?? new Uint8Array(0);
    message.key = object.key ?? new Uint8Array(0);
    return message;
  },
};

function createBaseKeyRing(): KeyRing {
  return { keys: [] };
}

export const KeyRing: MessageFns<KeyRing> = {
  encode(message: KeyRing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      InlineKey.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyRing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyRing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keys.push(InlineKey.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyRing {
    return { keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => InlineKey.fromJSON(e)) : [] };
  },

  toJSON(message: KeyRing): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => InlineKey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyRing>, I>>(base?: I): KeyRing {
    return KeyRing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyRing>, I>>(object: I): KeyRing {
    const message = createBaseKeyRing();
    message.keys = object.keys?.map((e) => InlineKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConfirmation(): Confirmation {
  return { messageId: new Uint8Array(0), proof: new Uint8Array(0) };
}

export const Confirmation: MessageFns<Confirmation> = {
  encode(message: Confirmation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId.length !== 0) {
      writer.uint32(10).bytes(message.messageId);
    }
    if (message.proof.length !== 0) {
      writer.uint32(18).bytes(message.proof);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Confirmation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proof = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Confirmation {
    return {
      messageId: isSet(object.messageId) ? bytesFromBase64(object.messageId) : new Uint8Array(0),
      proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(0),
    };
  },

  toJSON(message: Confirmation): unknown {
    const obj: any = {};
    if (message.messageId.length !== 0) {
      obj.messageId = base64FromBytes(message.messageId);
    }
    if (message.proof.length !== 0) {
      obj.proof = base64FromBytes(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Confirmation>, I>>(base?: I): Confirmation {
    return Confirmation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Confirmation>, I>>(object: I): Confirmation {
    const message = createBaseConfirmation();
    message.messageId = object.messageId ?? new Uint8Array(0);
    message.proof = object.proof ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDeliveryData(): DeliveryData {
  return { sharedKey: undefined, confirmation: undefined };
}

export const DeliveryData: MessageFns<DeliveryData> = {
  encode(message: DeliveryData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sharedKey !== undefined) {
      InlineKey.encode(message.sharedKey, writer.uint32(10).fork()).join();
    }
    if (message.confirmation !== undefined) {
      Confirmation.encode(message.confirmation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sharedKey = InlineKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.confirmation = Confirmation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryData {
    return {
      sharedKey: isSet(object.sharedKey) ? InlineKey.fromJSON(object.sharedKey) : undefined,
      confirmation: isSet(object.confirmation) ? Confirmation.fromJSON(object.confirmation) : undefined,
    };
  },

  toJSON(message: DeliveryData): unknown {
    const obj: any = {};
    if (message.sharedKey !== undefined) {
      obj.sharedKey = InlineKey.toJSON(message.sharedKey);
    }
    if (message.confirmation !== undefined) {
      obj.confirmation = Confirmation.toJSON(message.confirmation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeliveryData>, I>>(base?: I): DeliveryData {
    return DeliveryData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeliveryData>, I>>(object: I): DeliveryData {
    const message = createBaseDeliveryData();
    message.sharedKey = (object.sharedKey !== undefined && object.sharedKey !== null)
      ? InlineKey.fromPartial(object.sharedKey)
      : undefined;
    message.confirmation = (object.confirmation !== undefined && object.confirmation !== null)
      ? Confirmation.fromPartial(object.confirmation)
      : undefined;
    return message;
  },
};

function createBaseDeliveryMethod(): DeliveryMethod {
  return { deliveryType: 0, address: new Uint8Array(0) };
}

export const DeliveryMethod: MessageFns<DeliveryMethod> = {
  encode(message: DeliveryMethod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deliveryType !== 0) {
      writer.uint32(8).uint32(message.deliveryType);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryMethod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deliveryType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryMethod {
    return {
      deliveryType: isSet(object.deliveryType) ? globalThis.Number(object.deliveryType) : 0,
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
    };
  },

  toJSON(message: DeliveryMethod): unknown {
    const obj: any = {};
    if (message.deliveryType !== 0) {
      obj.deliveryType = Math.round(message.deliveryType);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeliveryMethod>, I>>(base?: I): DeliveryMethod {
    return DeliveryMethod.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeliveryMethod>, I>>(object: I): DeliveryMethod {
    const message = createBaseDeliveryMethod();
    message.deliveryType = object.deliveryType ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDecryptableAllowAccountRequest(): DecryptableAllowAccountRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableAllowAccountRequest: MessageFns<DecryptableAllowAccountRequest> = {
  encode(message: DecryptableAllowAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      AllowAccountRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableAllowAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableAllowAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = AllowAccountRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableAllowAccountRequest {
    return {
      request: isSet(object.request) ? AllowAccountRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableAllowAccountRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = AllowAccountRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableAllowAccountRequest>, I>>(base?: I): DecryptableAllowAccountRequest {
    return DecryptableAllowAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableAllowAccountRequest>, I>>(
    object: I,
  ): DecryptableAllowAccountRequest {
    const message = createBaseDecryptableAllowAccountRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? AllowAccountRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableBalanceAccountRequest(): DecryptableBalanceAccountRequest {
  return { request: undefined, keyRing: undefined };
}

export const DecryptableBalanceAccountRequest: MessageFns<DecryptableBalanceAccountRequest> = {
  encode(message: DecryptableBalanceAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      BalanceAccountRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableBalanceAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableBalanceAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = BalanceAccountRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableBalanceAccountRequest {
    return {
      request: isSet(object.request) ? BalanceAccountRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
    };
  },

  toJSON(message: DecryptableBalanceAccountRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = BalanceAccountRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableBalanceAccountRequest>, I>>(
    base?: I,
  ): DecryptableBalanceAccountRequest {
    return DecryptableBalanceAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableBalanceAccountRequest>, I>>(
    object: I,
  ): DecryptableBalanceAccountRequest {
    const message = createBaseDecryptableBalanceAccountRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? BalanceAccountRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    return message;
  },
};

function createBaseDecryptableCoinsAccountRequest(): DecryptableCoinsAccountRequest {
  return { request: undefined, keyRing: undefined };
}

export const DecryptableCoinsAccountRequest: MessageFns<DecryptableCoinsAccountRequest> = {
  encode(message: DecryptableCoinsAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      CoinsAccountRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableCoinsAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableCoinsAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = CoinsAccountRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableCoinsAccountRequest {
    return {
      request: isSet(object.request) ? CoinsAccountRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
    };
  },

  toJSON(message: DecryptableCoinsAccountRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = CoinsAccountRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableCoinsAccountRequest>, I>>(base?: I): DecryptableCoinsAccountRequest {
    return DecryptableCoinsAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableCoinsAccountRequest>, I>>(
    object: I,
  ): DecryptableCoinsAccountRequest {
    const message = createBaseDecryptableCoinsAccountRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? CoinsAccountRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    return message;
  },
};

function createBaseDecryptableRevokeAccountRequest(): DecryptableRevokeAccountRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableRevokeAccountRequest: MessageFns<DecryptableRevokeAccountRequest> = {
  encode(message: DecryptableRevokeAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      RevokeAccountRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableRevokeAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableRevokeAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = RevokeAccountRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableRevokeAccountRequest {
    return {
      request: isSet(object.request) ? RevokeAccountRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableRevokeAccountRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = RevokeAccountRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableRevokeAccountRequest>, I>>(base?: I): DecryptableRevokeAccountRequest {
    return DecryptableRevokeAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableRevokeAccountRequest>, I>>(
    object: I,
  ): DecryptableRevokeAccountRequest {
    const message = createBaseDecryptableRevokeAccountRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? RevokeAccountRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptablePendingTransactionsAccountRequest(): DecryptablePendingTransactionsAccountRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptablePendingTransactionsAccountRequest: MessageFns<DecryptablePendingTransactionsAccountRequest> = {
  encode(
    message: DecryptablePendingTransactionsAccountRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.request !== undefined) {
      PendingTransactionsAccountRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptablePendingTransactionsAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptablePendingTransactionsAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = PendingTransactionsAccountRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptablePendingTransactionsAccountRequest {
    return {
      request: isSet(object.request) ? PendingTransactionsAccountRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptablePendingTransactionsAccountRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = PendingTransactionsAccountRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptablePendingTransactionsAccountRequest>, I>>(
    base?: I,
  ): DecryptablePendingTransactionsAccountRequest {
    return DecryptablePendingTransactionsAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptablePendingTransactionsAccountRequest>, I>>(
    object: I,
  ): DecryptablePendingTransactionsAccountRequest {
    const message = createBaseDecryptablePendingTransactionsAccountRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? PendingTransactionsAccountRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableAllowCoinRequest(): DecryptableAllowCoinRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableAllowCoinRequest: MessageFns<DecryptableAllowCoinRequest> = {
  encode(message: DecryptableAllowCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      AllowCoinRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableAllowCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableAllowCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = AllowCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableAllowCoinRequest {
    return {
      request: isSet(object.request) ? AllowCoinRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableAllowCoinRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = AllowCoinRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableAllowCoinRequest>, I>>(base?: I): DecryptableAllowCoinRequest {
    return DecryptableAllowCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableAllowCoinRequest>, I>>(object: I): DecryptableAllowCoinRequest {
    const message = createBaseDecryptableAllowCoinRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? AllowCoinRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableIntersectCoinRequest(): DecryptableIntersectCoinRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableIntersectCoinRequest: MessageFns<DecryptableIntersectCoinRequest> = {
  encode(message: DecryptableIntersectCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      IntersectCoinRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableIntersectCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableIntersectCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = IntersectCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableIntersectCoinRequest {
    return {
      request: isSet(object.request) ? IntersectCoinRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableIntersectCoinRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = IntersectCoinRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableIntersectCoinRequest>, I>>(base?: I): DecryptableIntersectCoinRequest {
    return DecryptableIntersectCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableIntersectCoinRequest>, I>>(
    object: I,
  ): DecryptableIntersectCoinRequest {
    const message = createBaseDecryptableIntersectCoinRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? IntersectCoinRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableMergeCoinRequest(): DecryptableMergeCoinRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableMergeCoinRequest: MessageFns<DecryptableMergeCoinRequest> = {
  encode(message: DecryptableMergeCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      MergeCoinRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableMergeCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableMergeCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = MergeCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableMergeCoinRequest {
    return {
      request: isSet(object.request) ? MergeCoinRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableMergeCoinRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = MergeCoinRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableMergeCoinRequest>, I>>(base?: I): DecryptableMergeCoinRequest {
    return DecryptableMergeCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableMergeCoinRequest>, I>>(object: I): DecryptableMergeCoinRequest {
    const message = createBaseDecryptableMergeCoinRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? MergeCoinRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableMintCoinRequest(): DecryptableMintCoinRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableMintCoinRequest: MessageFns<DecryptableMintCoinRequest> = {
  encode(message: DecryptableMintCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      MintCoinRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableMintCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableMintCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = MintCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableMintCoinRequest {
    return {
      request: isSet(object.request) ? MintCoinRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableMintCoinRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = MintCoinRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableMintCoinRequest>, I>>(base?: I): DecryptableMintCoinRequest {
    return DecryptableMintCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableMintCoinRequest>, I>>(object: I): DecryptableMintCoinRequest {
    const message = createBaseDecryptableMintCoinRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? MintCoinRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableMutualReceiveCoinRequest(): DecryptableMutualReceiveCoinRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableMutualReceiveCoinRequest: MessageFns<DecryptableMutualReceiveCoinRequest> = {
  encode(message: DecryptableMutualReceiveCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      MutualReceiveCoinRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableMutualReceiveCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableMutualReceiveCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = MutualReceiveCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableMutualReceiveCoinRequest {
    return {
      request: isSet(object.request) ? MutualReceiveCoinRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableMutualReceiveCoinRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = MutualReceiveCoinRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableMutualReceiveCoinRequest>, I>>(
    base?: I,
  ): DecryptableMutualReceiveCoinRequest {
    return DecryptableMutualReceiveCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableMutualReceiveCoinRequest>, I>>(
    object: I,
  ): DecryptableMutualReceiveCoinRequest {
    const message = createBaseDecryptableMutualReceiveCoinRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? MutualReceiveCoinRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableMutualTransferCoinRequest(): DecryptableMutualTransferCoinRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableMutualTransferCoinRequest: MessageFns<DecryptableMutualTransferCoinRequest> = {
  encode(message: DecryptableMutualTransferCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      MutualTransferCoinRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableMutualTransferCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableMutualTransferCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = MutualTransferCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableMutualTransferCoinRequest {
    return {
      request: isSet(object.request) ? MutualTransferCoinRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableMutualTransferCoinRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = MutualTransferCoinRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableMutualTransferCoinRequest>, I>>(
    base?: I,
  ): DecryptableMutualTransferCoinRequest {
    return DecryptableMutualTransferCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableMutualTransferCoinRequest>, I>>(
    object: I,
  ): DecryptableMutualTransferCoinRequest {
    const message = createBaseDecryptableMutualTransferCoinRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? MutualTransferCoinRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableRevokeCoinRequest(): DecryptableRevokeCoinRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableRevokeCoinRequest: MessageFns<DecryptableRevokeCoinRequest> = {
  encode(message: DecryptableRevokeCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      RevokeCoinRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableRevokeCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableRevokeCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = RevokeCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableRevokeCoinRequest {
    return {
      request: isSet(object.request) ? RevokeCoinRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableRevokeCoinRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = RevokeCoinRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableRevokeCoinRequest>, I>>(base?: I): DecryptableRevokeCoinRequest {
    return DecryptableRevokeCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableRevokeCoinRequest>, I>>(object: I): DecryptableRevokeCoinRequest {
    const message = createBaseDecryptableRevokeCoinRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? RevokeCoinRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableSplitCoinRequest(): DecryptableSplitCoinRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableSplitCoinRequest: MessageFns<DecryptableSplitCoinRequest> = {
  encode(message: DecryptableSplitCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      SplitCoinRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableSplitCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableSplitCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = SplitCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableSplitCoinRequest {
    return {
      request: isSet(object.request) ? SplitCoinRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableSplitCoinRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = SplitCoinRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableSplitCoinRequest>, I>>(base?: I): DecryptableSplitCoinRequest {
    return DecryptableSplitCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableSplitCoinRequest>, I>>(object: I): DecryptableSplitCoinRequest {
    const message = createBaseDecryptableSplitCoinRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? SplitCoinRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableTransferCoinRequest(): DecryptableTransferCoinRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableTransferCoinRequest: MessageFns<DecryptableTransferCoinRequest> = {
  encode(message: DecryptableTransferCoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      TransferCoinRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableTransferCoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableTransferCoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = TransferCoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableTransferCoinRequest {
    return {
      request: isSet(object.request) ? TransferCoinRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableTransferCoinRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = TransferCoinRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableTransferCoinRequest>, I>>(base?: I): DecryptableTransferCoinRequest {
    return DecryptableTransferCoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableTransferCoinRequest>, I>>(
    object: I,
  ): DecryptableTransferCoinRequest {
    const message = createBaseDecryptableTransferCoinRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? TransferCoinRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableApprovePendingTransactionRequest(): DecryptableApprovePendingTransactionRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableApprovePendingTransactionRequest: MessageFns<DecryptableApprovePendingTransactionRequest> = {
  encode(
    message: DecryptableApprovePendingTransactionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.request !== undefined) {
      ApprovePendingTransactionRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableApprovePendingTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableApprovePendingTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = ApprovePendingTransactionRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableApprovePendingTransactionRequest {
    return {
      request: isSet(object.request) ? ApprovePendingTransactionRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableApprovePendingTransactionRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = ApprovePendingTransactionRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableApprovePendingTransactionRequest>, I>>(
    base?: I,
  ): DecryptableApprovePendingTransactionRequest {
    return DecryptableApprovePendingTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableApprovePendingTransactionRequest>, I>>(
    object: I,
  ): DecryptableApprovePendingTransactionRequest {
    const message = createBaseDecryptableApprovePendingTransactionRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? ApprovePendingTransactionRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseDecryptableRejectPendingTransactionRequest(): DecryptableRejectPendingTransactionRequest {
  return { request: undefined, keyRing: undefined, deliveryMethod: undefined };
}

export const DecryptableRejectPendingTransactionRequest: MessageFns<DecryptableRejectPendingTransactionRequest> = {
  encode(message: DecryptableRejectPendingTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      RejectPendingTransactionRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(18).fork()).join();
    }
    if (message.deliveryMethod !== undefined) {
      DeliveryMethod.encode(message.deliveryMethod, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptableRejectPendingTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptableRejectPendingTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = RejectPendingTransactionRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deliveryMethod = DeliveryMethod.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptableRejectPendingTransactionRequest {
    return {
      request: isSet(object.request) ? RejectPendingTransactionRequest.fromJSON(object.request) : undefined,
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
      deliveryMethod: isSet(object.deliveryMethod) ? DeliveryMethod.fromJSON(object.deliveryMethod) : undefined,
    };
  },

  toJSON(message: DecryptableRejectPendingTransactionRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = RejectPendingTransactionRequest.toJSON(message.request);
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    if (message.deliveryMethod !== undefined) {
      obj.deliveryMethod = DeliveryMethod.toJSON(message.deliveryMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptableRejectPendingTransactionRequest>, I>>(
    base?: I,
  ): DecryptableRejectPendingTransactionRequest {
    return DecryptableRejectPendingTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptableRejectPendingTransactionRequest>, I>>(
    object: I,
  ): DecryptableRejectPendingTransactionRequest {
    const message = createBaseDecryptableRejectPendingTransactionRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? RejectPendingTransactionRequest.fromPartial(object.request)
      : undefined;
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    message.deliveryMethod = (object.deliveryMethod !== undefined && object.deliveryMethod !== null)
      ? DeliveryMethod.fromPartial(object.deliveryMethod)
      : undefined;
    return message;
  },
};

function createBaseCoinInfo(): CoinInfo {
  return { coin: undefined, balance: new Uint8Array(0) };
}

export const CoinInfo: MessageFns<CoinInfo> = {
  encode(message: CoinInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coin !== undefined) {
      CoinRef.encode(message.coin, writer.uint32(10).fork()).join();
    }
    if (message.balance.length !== 0) {
      writer.uint32(18).bytes(message.balance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoinInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.balance = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoinInfo {
    return {
      coin: isSet(object.coin) ? CoinRef.fromJSON(object.coin) : undefined,
      balance: isSet(object.balance) ? bytesFromBase64(object.balance) : new Uint8Array(0),
    };
  },

  toJSON(message: CoinInfo): unknown {
    const obj: any = {};
    if (message.coin !== undefined) {
      obj.coin = CoinRef.toJSON(message.coin);
    }
    if (message.balance.length !== 0) {
      obj.balance = base64FromBytes(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoinInfo>, I>>(base?: I): CoinInfo {
    return CoinInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoinInfo>, I>>(object: I): CoinInfo {
    const message = createBaseCoinInfo();
    message.coin = (object.coin !== undefined && object.coin !== null) ? CoinRef.fromPartial(object.coin) : undefined;
    message.balance = object.balance ?? new Uint8Array(0);
    return message;
  },
};

function createBasePendingTransactionInfo(): PendingTransactionInfo {
  return { pendingTransaction: undefined, coin: undefined, refundAccount: undefined };
}

export const PendingTransactionInfo: MessageFns<PendingTransactionInfo> = {
  encode(message: PendingTransactionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pendingTransaction !== undefined) {
      PendingTransactionRef.encode(message.pendingTransaction, writer.uint32(10).fork()).join();
    }
    if (message.coin !== undefined) {
      CoinInfo.encode(message.coin, writer.uint32(18).fork()).join();
    }
    if (message.refundAccount !== undefined) {
      AccountRef.encode(message.refundAccount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingTransactionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingTransactionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pendingTransaction = PendingTransactionRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.coin = CoinInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundAccount = AccountRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingTransactionInfo {
    return {
      pendingTransaction: isSet(object.pendingTransaction)
        ? PendingTransactionRef.fromJSON(object.pendingTransaction)
        : undefined,
      coin: isSet(object.coin) ? CoinInfo.fromJSON(object.coin) : undefined,
      refundAccount: isSet(object.refundAccount) ? AccountRef.fromJSON(object.refundAccount) : undefined,
    };
  },

  toJSON(message: PendingTransactionInfo): unknown {
    const obj: any = {};
    if (message.pendingTransaction !== undefined) {
      obj.pendingTransaction = PendingTransactionRef.toJSON(message.pendingTransaction);
    }
    if (message.coin !== undefined) {
      obj.coin = CoinInfo.toJSON(message.coin);
    }
    if (message.refundAccount !== undefined) {
      obj.refundAccount = AccountRef.toJSON(message.refundAccount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingTransactionInfo>, I>>(base?: I): PendingTransactionInfo {
    return PendingTransactionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingTransactionInfo>, I>>(object: I): PendingTransactionInfo {
    const message = createBasePendingTransactionInfo();
    message.pendingTransaction = (object.pendingTransaction !== undefined && object.pendingTransaction !== null)
      ? PendingTransactionRef.fromPartial(object.pendingTransaction)
      : undefined;
    message.coin = (object.coin !== undefined && object.coin !== null) ? CoinInfo.fromPartial(object.coin) : undefined;
    message.refundAccount = (object.refundAccount !== undefined && object.refundAccount !== null)
      ? AccountRef.fromPartial(object.refundAccount)
      : undefined;
    return message;
  },
};

function createBaseAllowAccountResponse(): AllowAccountResponse {
  return { allowance: undefined, deliveries: [] };
}

export const AllowAccountResponse: MessageFns<AllowAccountResponse> = {
  encode(message: AllowAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowance !== undefined) {
      AccountAllowanceRef.encode(message.allowance, writer.uint32(10).fork()).join();
    }
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allowance = AccountAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowAccountResponse {
    return {
      allowance: isSet(object.allowance) ? AccountAllowanceRef.fromJSON(object.allowance) : undefined,
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AllowAccountResponse): unknown {
    const obj: any = {};
    if (message.allowance !== undefined) {
      obj.allowance = AccountAllowanceRef.toJSON(message.allowance);
    }
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowAccountResponse>, I>>(base?: I): AllowAccountResponse {
    return AllowAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowAccountResponse>, I>>(object: I): AllowAccountResponse {
    const message = createBaseAllowAccountResponse();
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? AccountAllowanceRef.fromPartial(object.allowance)
      : undefined;
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBalanceAccountResponse(): BalanceAccountResponse {
  return { balance: new Uint8Array(0) };
}

export const BalanceAccountResponse: MessageFns<BalanceAccountResponse> = {
  encode(message: BalanceAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance.length !== 0) {
      writer.uint32(10).bytes(message.balance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balance = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceAccountResponse {
    return { balance: isSet(object.balance) ? bytesFromBase64(object.balance) : new Uint8Array(0) };
  },

  toJSON(message: BalanceAccountResponse): unknown {
    const obj: any = {};
    if (message.balance.length !== 0) {
      obj.balance = base64FromBytes(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceAccountResponse>, I>>(base?: I): BalanceAccountResponse {
    return BalanceAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceAccountResponse>, I>>(object: I): BalanceAccountResponse {
    const message = createBaseBalanceAccountResponse();
    message.balance = object.balance ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCoinsAccountResponse(): CoinsAccountResponse {
  return { coins: [] };
}

export const CoinsAccountResponse: MessageFns<CoinsAccountResponse> = {
  encode(message: CoinsAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.coins) {
      CoinInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoinsAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinsAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coins.push(CoinInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoinsAccountResponse {
    return { coins: globalThis.Array.isArray(object?.coins) ? object.coins.map((e: any) => CoinInfo.fromJSON(e)) : [] };
  },

  toJSON(message: CoinsAccountResponse): unknown {
    const obj: any = {};
    if (message.coins?.length) {
      obj.coins = message.coins.map((e) => CoinInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoinsAccountResponse>, I>>(base?: I): CoinsAccountResponse {
    return CoinsAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoinsAccountResponse>, I>>(object: I): CoinsAccountResponse {
    const message = createBaseCoinsAccountResponse();
    message.coins = object.coins?.map((e) => CoinInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasePendingTransactionsAccountResponse(): PendingTransactionsAccountResponse {
  return { pendingTransactions: [] };
}

export const PendingTransactionsAccountResponse: MessageFns<PendingTransactionsAccountResponse> = {
  encode(message: PendingTransactionsAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pendingTransactions) {
      PendingTransactionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingTransactionsAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingTransactionsAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pendingTransactions.push(PendingTransactionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingTransactionsAccountResponse {
    return {
      pendingTransactions: globalThis.Array.isArray(object?.pendingTransactions)
        ? object.pendingTransactions.map((e: any) => PendingTransactionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PendingTransactionsAccountResponse): unknown {
    const obj: any = {};
    if (message.pendingTransactions?.length) {
      obj.pendingTransactions = message.pendingTransactions.map((e) => PendingTransactionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingTransactionsAccountResponse>, I>>(
    base?: I,
  ): PendingTransactionsAccountResponse {
    return PendingTransactionsAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingTransactionsAccountResponse>, I>>(
    object: I,
  ): PendingTransactionsAccountResponse {
    const message = createBasePendingTransactionsAccountResponse();
    message.pendingTransactions = object.pendingTransactions?.map((e) => PendingTransactionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRevokeAccountResponse(): RevokeAccountResponse {
  return { deliveries: [] };
}

export const RevokeAccountResponse: MessageFns<RevokeAccountResponse> = {
  encode(message: RevokeAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeAccountResponse {
    return {
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RevokeAccountResponse): unknown {
    const obj: any = {};
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeAccountResponse>, I>>(base?: I): RevokeAccountResponse {
    return RevokeAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeAccountResponse>, I>>(object: I): RevokeAccountResponse {
    const message = createBaseRevokeAccountResponse();
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAllowCoinResponse(): AllowCoinResponse {
  return { allowance: undefined, deliveries: [] };
}

export const AllowCoinResponse: MessageFns<AllowCoinResponse> = {
  encode(message: AllowCoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowance !== undefined) {
      CoinAllowanceRef.encode(message.allowance, writer.uint32(10).fork()).join();
    }
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowCoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowCoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allowance = CoinAllowanceRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowCoinResponse {
    return {
      allowance: isSet(object.allowance) ? CoinAllowanceRef.fromJSON(object.allowance) : undefined,
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AllowCoinResponse): unknown {
    const obj: any = {};
    if (message.allowance !== undefined) {
      obj.allowance = CoinAllowanceRef.toJSON(message.allowance);
    }
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowCoinResponse>, I>>(base?: I): AllowCoinResponse {
    return AllowCoinResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowCoinResponse>, I>>(object: I): AllowCoinResponse {
    const message = createBaseAllowCoinResponse();
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? CoinAllowanceRef.fromPartial(object.allowance)
      : undefined;
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIntersectCoinResponse(): IntersectCoinResponse {
  return { intersects: false };
}

export const IntersectCoinResponse: MessageFns<IntersectCoinResponse> = {
  encode(message: IntersectCoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intersects !== false) {
      writer.uint32(8).bool(message.intersects);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntersectCoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntersectCoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.intersects = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntersectCoinResponse {
    return { intersects: isSet(object.intersects) ? globalThis.Boolean(object.intersects) : false };
  },

  toJSON(message: IntersectCoinResponse): unknown {
    const obj: any = {};
    if (message.intersects !== false) {
      obj.intersects = message.intersects;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntersectCoinResponse>, I>>(base?: I): IntersectCoinResponse {
    return IntersectCoinResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntersectCoinResponse>, I>>(object: I): IntersectCoinResponse {
    const message = createBaseIntersectCoinResponse();
    message.intersects = object.intersects ?? false;
    return message;
  },
};

function createBaseMergeCoinResponse(): MergeCoinResponse {
  return { coin: undefined, deliveries: [] };
}

export const MergeCoinResponse: MessageFns<MergeCoinResponse> = {
  encode(message: MergeCoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coin !== undefined) {
      CoinRef.encode(message.coin, writer.uint32(10).fork()).join();
    }
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeCoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeCoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeCoinResponse {
    return {
      coin: isSet(object.coin) ? CoinRef.fromJSON(object.coin) : undefined,
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MergeCoinResponse): unknown {
    const obj: any = {};
    if (message.coin !== undefined) {
      obj.coin = CoinRef.toJSON(message.coin);
    }
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MergeCoinResponse>, I>>(base?: I): MergeCoinResponse {
    return MergeCoinResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MergeCoinResponse>, I>>(object: I): MergeCoinResponse {
    const message = createBaseMergeCoinResponse();
    message.coin = (object.coin !== undefined && object.coin !== null) ? CoinRef.fromPartial(object.coin) : undefined;
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMintCoinResponse(): MintCoinResponse {
  return { coins: [], deliveries: [] };
}

export const MintCoinResponse: MessageFns<MintCoinResponse> = {
  encode(message: MintCoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.coins) {
      CoinInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MintCoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintCoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coins.push(CoinInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintCoinResponse {
    return {
      coins: globalThis.Array.isArray(object?.coins) ? object.coins.map((e: any) => CoinInfo.fromJSON(e)) : [],
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MintCoinResponse): unknown {
    const obj: any = {};
    if (message.coins?.length) {
      obj.coins = message.coins.map((e) => CoinInfo.toJSON(e));
    }
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MintCoinResponse>, I>>(base?: I): MintCoinResponse {
    return MintCoinResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MintCoinResponse>, I>>(object: I): MintCoinResponse {
    const message = createBaseMintCoinResponse();
    message.coins = object.coins?.map((e) => CoinInfo.fromPartial(e)) || [];
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMutualReceiveCoinResponse(): MutualReceiveCoinResponse {
  return { status: 0, rendezvous: new Uint8Array(0), coin: undefined, deliveries: [] };
}

export const MutualReceiveCoinResponse: MessageFns<MutualReceiveCoinResponse> = {
  encode(message: MutualReceiveCoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).uint32(message.status);
    }
    if (message.rendezvous.length !== 0) {
      writer.uint32(18).bytes(message.rendezvous);
    }
    if (message.coin !== undefined) {
      CoinRef.encode(message.coin, writer.uint32(26).fork()).join();
    }
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutualReceiveCoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutualReceiveCoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rendezvous = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.coin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutualReceiveCoinResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      rendezvous: isSet(object.rendezvous) ? bytesFromBase64(object.rendezvous) : new Uint8Array(0),
      coin: isSet(object.coin) ? CoinRef.fromJSON(object.coin) : undefined,
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MutualReceiveCoinResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.rendezvous.length !== 0) {
      obj.rendezvous = base64FromBytes(message.rendezvous);
    }
    if (message.coin !== undefined) {
      obj.coin = CoinRef.toJSON(message.coin);
    }
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutualReceiveCoinResponse>, I>>(base?: I): MutualReceiveCoinResponse {
    return MutualReceiveCoinResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutualReceiveCoinResponse>, I>>(object: I): MutualReceiveCoinResponse {
    const message = createBaseMutualReceiveCoinResponse();
    message.status = object.status ?? 0;
    message.rendezvous = object.rendezvous ?? new Uint8Array(0);
    message.coin = (object.coin !== undefined && object.coin !== null) ? CoinRef.fromPartial(object.coin) : undefined;
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMutualTransferCoinResponse(): MutualTransferCoinResponse {
  return { status: 0, deliveries: [] };
}

export const MutualTransferCoinResponse: MessageFns<MutualTransferCoinResponse> = {
  encode(message: MutualTransferCoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).uint32(message.status);
    }
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutualTransferCoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutualTransferCoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutualTransferCoinResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MutualTransferCoinResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutualTransferCoinResponse>, I>>(base?: I): MutualTransferCoinResponse {
    return MutualTransferCoinResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutualTransferCoinResponse>, I>>(object: I): MutualTransferCoinResponse {
    const message = createBaseMutualTransferCoinResponse();
    message.status = object.status ?? 0;
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRevokeCoinResponse(): RevokeCoinResponse {
  return { deliveries: [] };
}

export const RevokeCoinResponse: MessageFns<RevokeCoinResponse> = {
  encode(message: RevokeCoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeCoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeCoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeCoinResponse {
    return {
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RevokeCoinResponse): unknown {
    const obj: any = {};
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeCoinResponse>, I>>(base?: I): RevokeCoinResponse {
    return RevokeCoinResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeCoinResponse>, I>>(object: I): RevokeCoinResponse {
    const message = createBaseRevokeCoinResponse();
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSplitCoinResponse(): SplitCoinResponse {
  return { coins: [], deliveries: [] };
}

export const SplitCoinResponse: MessageFns<SplitCoinResponse> = {
  encode(message: SplitCoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.coins) {
      CoinRef.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplitCoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplitCoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coins.push(CoinRef.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplitCoinResponse {
    return {
      coins: globalThis.Array.isArray(object?.coins) ? object.coins.map((e: any) => CoinRef.fromJSON(e)) : [],
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SplitCoinResponse): unknown {
    const obj: any = {};
    if (message.coins?.length) {
      obj.coins = message.coins.map((e) => CoinRef.toJSON(e));
    }
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SplitCoinResponse>, I>>(base?: I): SplitCoinResponse {
    return SplitCoinResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SplitCoinResponse>, I>>(object: I): SplitCoinResponse {
    const message = createBaseSplitCoinResponse();
    message.coins = object.coins?.map((e) => CoinRef.fromPartial(e)) || [];
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransferCoinResponse(): TransferCoinResponse {
  return { pendingTransaction: undefined, deliveries: [] };
}

export const TransferCoinResponse: MessageFns<TransferCoinResponse> = {
  encode(message: TransferCoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pendingTransaction !== undefined) {
      PendingTransactionRef.encode(message.pendingTransaction, writer.uint32(10).fork()).join();
    }
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferCoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferCoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pendingTransaction = PendingTransactionRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferCoinResponse {
    return {
      pendingTransaction: isSet(object.pendingTransaction)
        ? PendingTransactionRef.fromJSON(object.pendingTransaction)
        : undefined,
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransferCoinResponse): unknown {
    const obj: any = {};
    if (message.pendingTransaction !== undefined) {
      obj.pendingTransaction = PendingTransactionRef.toJSON(message.pendingTransaction);
    }
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferCoinResponse>, I>>(base?: I): TransferCoinResponse {
    return TransferCoinResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferCoinResponse>, I>>(object: I): TransferCoinResponse {
    const message = createBaseTransferCoinResponse();
    message.pendingTransaction = (object.pendingTransaction !== undefined && object.pendingTransaction !== null)
      ? PendingTransactionRef.fromPartial(object.pendingTransaction)
      : undefined;
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseApprovePendingTransactionResponse(): ApprovePendingTransactionResponse {
  return { coin: undefined, deliveries: [] };
}

export const ApprovePendingTransactionResponse: MessageFns<ApprovePendingTransactionResponse> = {
  encode(message: ApprovePendingTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coin !== undefined) {
      CoinRef.encode(message.coin, writer.uint32(10).fork()).join();
    }
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApprovePendingTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApprovePendingTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coin = CoinRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApprovePendingTransactionResponse {
    return {
      coin: isSet(object.coin) ? CoinRef.fromJSON(object.coin) : undefined,
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ApprovePendingTransactionResponse): unknown {
    const obj: any = {};
    if (message.coin !== undefined) {
      obj.coin = CoinRef.toJSON(message.coin);
    }
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApprovePendingTransactionResponse>, I>>(
    base?: I,
  ): ApprovePendingTransactionResponse {
    return ApprovePendingTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApprovePendingTransactionResponse>, I>>(
    object: I,
  ): ApprovePendingTransactionResponse {
    const message = createBaseApprovePendingTransactionResponse();
    message.coin = (object.coin !== undefined && object.coin !== null) ? CoinRef.fromPartial(object.coin) : undefined;
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRejectPendingTransactionResponse(): RejectPendingTransactionResponse {
  return { deliveries: [] };
}

export const RejectPendingTransactionResponse: MessageFns<RejectPendingTransactionResponse> = {
  encode(message: RejectPendingTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deliveries) {
      DeliveryData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RejectPendingTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectPendingTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveries.push(DeliveryData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RejectPendingTransactionResponse {
    return {
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => DeliveryData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RejectPendingTransactionResponse): unknown {
    const obj: any = {};
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => DeliveryData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RejectPendingTransactionResponse>, I>>(
    base?: I,
  ): RejectPendingTransactionResponse {
    return RejectPendingTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RejectPendingTransactionResponse>, I>>(
    object: I,
  ): RejectPendingTransactionResponse {
    const message = createBaseRejectPendingTransactionResponse();
    message.deliveries = object.deliveries?.map((e) => DeliveryData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSendMessageResponse(): SendMessageResponse {
  return {};
}

export const SendMessageResponse: MessageFns<SendMessageResponse> = {
  encode(_: SendMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SendMessageResponse {
    return {};
  },

  toJSON(_: SendMessageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageResponse>, I>>(base?: I): SendMessageResponse {
    return SendMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageResponse>, I>>(_: I): SendMessageResponse {
    const message = createBaseSendMessageResponse();
    return message;
  },
};

function createBaseGetTokensByAccountRequest(): GetTokensByAccountRequest {
  return { address: new Uint8Array(0) };
}

export const GetTokensByAccountRequest: MessageFns<GetTokensByAccountRequest> = {
  encode(message: GetTokensByAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokensByAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokensByAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokensByAccountRequest {
    return { address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0) };
  },

  toJSON(message: GetTokensByAccountRequest): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokensByAccountRequest>, I>>(base?: I): GetTokensByAccountRequest {
    return GetTokensByAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokensByAccountRequest>, I>>(object: I): GetTokensByAccountRequest {
    const message = createBaseGetTokensByAccountRequest();
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokensByAccountResponse(): TokensByAccountResponse {
  return { coins: [], frameNumbers: [], addresses: [] };
}

export const TokensByAccountResponse: MessageFns<TokensByAccountResponse> = {
  encode(message: TokensByAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.coins) {
      Coin.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.frameNumbers) {
      writer.uint64(v.toString());
    }
    writer.join();
    for (const v of message.addresses) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokensByAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokensByAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coins.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.frameNumbers.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.frameNumbers.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addresses.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokensByAccountResponse {
    return {
      coins: globalThis.Array.isArray(object?.coins) ? object.coins.map((e: any) => Coin.fromJSON(e)) : [],
      frameNumbers: globalThis.Array.isArray(object?.frameNumbers)
        ? object.frameNumbers.map((e: any) => Long.fromValue(e))
        : [],
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: TokensByAccountResponse): unknown {
    const obj: any = {};
    if (message.coins?.length) {
      obj.coins = message.coins.map((e) => Coin.toJSON(e));
    }
    if (message.frameNumbers?.length) {
      obj.frameNumbers = message.frameNumbers.map((e) => (e || Long.UZERO).toString());
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokensByAccountResponse>, I>>(base?: I): TokensByAccountResponse {
    return TokensByAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokensByAccountResponse>, I>>(object: I): TokensByAccountResponse {
    const message = createBaseTokensByAccountResponse();
    message.coins = object.coins?.map((e) => Coin.fromPartial(e)) || [];
    message.frameNumbers = object.frameNumbers?.map((e) => Long.fromValue(e)) || [];
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetPreCoinProofsByAccountRequest(): GetPreCoinProofsByAccountRequest {
  return { address: new Uint8Array(0) };
}

export const GetPreCoinProofsByAccountRequest: MessageFns<GetPreCoinProofsByAccountRequest> = {
  encode(message: GetPreCoinProofsByAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreCoinProofsByAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreCoinProofsByAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreCoinProofsByAccountRequest {
    return { address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0) };
  },

  toJSON(message: GetPreCoinProofsByAccountRequest): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPreCoinProofsByAccountRequest>, I>>(
    base?: I,
  ): GetPreCoinProofsByAccountRequest {
    return GetPreCoinProofsByAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPreCoinProofsByAccountRequest>, I>>(
    object: I,
  ): GetPreCoinProofsByAccountRequest {
    const message = createBaseGetPreCoinProofsByAccountRequest();
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBasePreCoinProofsByAccountResponse(): PreCoinProofsByAccountResponse {
  return { proofs: [], frameNumbers: [] };
}

export const PreCoinProofsByAccountResponse: MessageFns<PreCoinProofsByAccountResponse> = {
  encode(message: PreCoinProofsByAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.proofs) {
      PreCoinProof.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.frameNumbers) {
      writer.uint64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreCoinProofsByAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreCoinProofsByAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofs.push(PreCoinProof.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.frameNumbers.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.frameNumbers.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreCoinProofsByAccountResponse {
    return {
      proofs: globalThis.Array.isArray(object?.proofs) ? object.proofs.map((e: any) => PreCoinProof.fromJSON(e)) : [],
      frameNumbers: globalThis.Array.isArray(object?.frameNumbers)
        ? object.frameNumbers.map((e: any) => Long.fromValue(e))
        : [],
    };
  },

  toJSON(message: PreCoinProofsByAccountResponse): unknown {
    const obj: any = {};
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => PreCoinProof.toJSON(e));
    }
    if (message.frameNumbers?.length) {
      obj.frameNumbers = message.frameNumbers.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreCoinProofsByAccountResponse>, I>>(base?: I): PreCoinProofsByAccountResponse {
    return PreCoinProofsByAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreCoinProofsByAccountResponse>, I>>(
    object: I,
  ): PreCoinProofsByAccountResponse {
    const message = createBasePreCoinProofsByAccountResponse();
    message.proofs = object.proofs?.map((e) => PreCoinProof.fromPartial(e)) || [];
    message.frameNumbers = object.frameNumbers?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

export interface ValidationService {
  PerformValidation(request: ValidationMessage): Promise<ValidationMessage>;
  Sync(request: SyncRequest): Observable<SyncResponse>;
}

export const ValidationServiceServiceName = "quilibrium.node.node.pb.ValidationService";
export class ValidationServiceClientImpl implements ValidationService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ValidationServiceServiceName;
    this.rpc = rpc;
    this.PerformValidation = this.PerformValidation.bind(this);
    this.Sync = this.Sync.bind(this);
  }
  PerformValidation(request: ValidationMessage): Promise<ValidationMessage> {
    const data = ValidationMessage.encode(request).finish();
    const promise = this.rpc.request(this.service, "PerformValidation", data);
    return promise.then((data) => ValidationMessage.decode(new BinaryReader(data)));
  }

  Sync(request: SyncRequest): Observable<SyncResponse> {
    const data = SyncRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "Sync", data);
    return result.pipe(map((data) => SyncResponse.decode(new BinaryReader(data))));
  }
}

export interface NodeService {
  GetFrames(request: GetFramesRequest): Promise<FramesResponse>;
  GetFrameInfo(request: GetFrameInfoRequest): Promise<FrameInfoResponse>;
  GetPeerInfo(request: GetPeerInfoRequest): Promise<PeerInfoResponse>;
  GetNodeInfo(request: GetNodeInfoRequest): Promise<NodeInfoResponse>;
  GetNetworkInfo(request: GetNetworkInfoRequest): Promise<NetworkInfoResponse>;
  GetTokenInfo(request: GetTokenInfoRequest): Promise<TokenInfoResponse>;
  GetPeerManifests(request: GetPeerManifestsRequest): Promise<PeerManifestsResponse>;
  SendMessage(request: TokenRequest): Promise<SendMessageResponse>;
  GetTokensByAccount(request: GetTokensByAccountRequest): Promise<TokensByAccountResponse>;
  GetPreCoinProofsByAccount(request: GetPreCoinProofsByAccountRequest): Promise<PreCoinProofsByAccountResponse>;
}

export const NodeServiceServiceName = "quilibrium.node.node.pb.NodeService";
export class NodeServiceClientImpl implements NodeService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || NodeServiceServiceName;
    this.rpc = rpc;
    this.GetFrames = this.GetFrames.bind(this);
    this.GetFrameInfo = this.GetFrameInfo.bind(this);
    this.GetPeerInfo = this.GetPeerInfo.bind(this);
    this.GetNodeInfo = this.GetNodeInfo.bind(this);
    this.GetNetworkInfo = this.GetNetworkInfo.bind(this);
    this.GetTokenInfo = this.GetTokenInfo.bind(this);
    this.GetPeerManifests = this.GetPeerManifests.bind(this);
    this.SendMessage = this.SendMessage.bind(this);
    this.GetTokensByAccount = this.GetTokensByAccount.bind(this);
    this.GetPreCoinProofsByAccount = this.GetPreCoinProofsByAccount.bind(this);
  }
  GetFrames(request: GetFramesRequest): Promise<FramesResponse> {
    const data = GetFramesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetFrames", data);
    return promise.then((data) => FramesResponse.decode(new BinaryReader(data)));
  }

  GetFrameInfo(request: GetFrameInfoRequest): Promise<FrameInfoResponse> {
    const data = GetFrameInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetFrameInfo", data);
    return promise.then((data) => FrameInfoResponse.decode(new BinaryReader(data)));
  }

  GetPeerInfo(request: GetPeerInfoRequest): Promise<PeerInfoResponse> {
    const data = GetPeerInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPeerInfo", data);
    return promise.then((data) => PeerInfoResponse.decode(new BinaryReader(data)));
  }

  GetNodeInfo(request: GetNodeInfoRequest): Promise<NodeInfoResponse> {
    const data = GetNodeInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNodeInfo", data);
    return promise.then((data) => NodeInfoResponse.decode(new BinaryReader(data)));
  }

  GetNetworkInfo(request: GetNetworkInfoRequest): Promise<NetworkInfoResponse> {
    const data = GetNetworkInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNetworkInfo", data);
    return promise.then((data) => NetworkInfoResponse.decode(new BinaryReader(data)));
  }

  GetTokenInfo(request: GetTokenInfoRequest): Promise<TokenInfoResponse> {
    const data = GetTokenInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTokenInfo", data);
    return promise.then((data) => TokenInfoResponse.decode(new BinaryReader(data)));
  }

  GetPeerManifests(request: GetPeerManifestsRequest): Promise<PeerManifestsResponse> {
    const data = GetPeerManifestsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPeerManifests", data);
    return promise.then((data) => PeerManifestsResponse.decode(new BinaryReader(data)));
  }

  SendMessage(request: TokenRequest): Promise<SendMessageResponse> {
    const data = TokenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendMessage", data);
    return promise.then((data) => SendMessageResponse.decode(new BinaryReader(data)));
  }

  GetTokensByAccount(request: GetTokensByAccountRequest): Promise<TokensByAccountResponse> {
    const data = GetTokensByAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTokensByAccount", data);
    return promise.then((data) => TokensByAccountResponse.decode(new BinaryReader(data)));
  }

  GetPreCoinProofsByAccount(request: GetPreCoinProofsByAccountRequest): Promise<PreCoinProofsByAccountResponse> {
    const data = GetPreCoinProofsByAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreCoinProofsByAccount", data);
    return promise.then((data) => PreCoinProofsByAccountResponse.decode(new BinaryReader(data)));
  }
}

export interface AccountService {
  Allow(request: DecryptableAllowAccountRequest): Promise<AllowAccountResponse>;
  GetBalance(request: DecryptableBalanceAccountRequest): Promise<BalanceAccountResponse>;
  ListCoins(request: DecryptableCoinsAccountRequest): Promise<CoinsAccountResponse>;
  ListPendingTransactions(
    request: DecryptablePendingTransactionsAccountRequest,
  ): Promise<PendingTransactionsAccountResponse>;
  Revoke(request: DecryptableRevokeAccountRequest): Promise<RevokeAccountResponse>;
}

export const AccountServiceServiceName = "quilibrium.node.node.pb.AccountService";
export class AccountServiceClientImpl implements AccountService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AccountServiceServiceName;
    this.rpc = rpc;
    this.Allow = this.Allow.bind(this);
    this.GetBalance = this.GetBalance.bind(this);
    this.ListCoins = this.ListCoins.bind(this);
    this.ListPendingTransactions = this.ListPendingTransactions.bind(this);
    this.Revoke = this.Revoke.bind(this);
  }
  Allow(request: DecryptableAllowAccountRequest): Promise<AllowAccountResponse> {
    const data = DecryptableAllowAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Allow", data);
    return promise.then((data) => AllowAccountResponse.decode(new BinaryReader(data)));
  }

  GetBalance(request: DecryptableBalanceAccountRequest): Promise<BalanceAccountResponse> {
    const data = DecryptableBalanceAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBalance", data);
    return promise.then((data) => BalanceAccountResponse.decode(new BinaryReader(data)));
  }

  ListCoins(request: DecryptableCoinsAccountRequest): Promise<CoinsAccountResponse> {
    const data = DecryptableCoinsAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListCoins", data);
    return promise.then((data) => CoinsAccountResponse.decode(new BinaryReader(data)));
  }

  ListPendingTransactions(
    request: DecryptablePendingTransactionsAccountRequest,
  ): Promise<PendingTransactionsAccountResponse> {
    const data = DecryptablePendingTransactionsAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListPendingTransactions", data);
    return promise.then((data) => PendingTransactionsAccountResponse.decode(new BinaryReader(data)));
  }

  Revoke(request: DecryptableRevokeAccountRequest): Promise<RevokeAccountResponse> {
    const data = DecryptableRevokeAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Revoke", data);
    return promise.then((data) => RevokeAccountResponse.decode(new BinaryReader(data)));
  }
}

export interface CoinService {
  Allow(request: DecryptableAllowCoinRequest): Promise<AllowCoinResponse>;
  Intersect(request: DecryptableIntersectCoinRequest): Promise<IntersectCoinResponse>;
  Merge(request: DecryptableMergeCoinRequest): Promise<MergeCoinResponse>;
  Mint(request: DecryptableMintCoinRequest): Promise<MintCoinResponse>;
  MutualReceive(request: DecryptableMutualReceiveCoinRequest): Observable<MutualReceiveCoinResponse>;
  MutualTransfer(request: DecryptableMutualTransferCoinRequest): Observable<MutualTransferCoinResponse>;
  Revoke(request: DecryptableRevokeCoinRequest): Promise<RevokeCoinResponse>;
  Split(request: DecryptableSplitCoinRequest): Promise<SplitCoinResponse>;
  Transfer(request: DecryptableTransferCoinRequest): Promise<TransferCoinResponse>;
}

export const CoinServiceServiceName = "quilibrium.node.node.pb.CoinService";
export class CoinServiceClientImpl implements CoinService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || CoinServiceServiceName;
    this.rpc = rpc;
    this.Allow = this.Allow.bind(this);
    this.Intersect = this.Intersect.bind(this);
    this.Merge = this.Merge.bind(this);
    this.Mint = this.Mint.bind(this);
    this.MutualReceive = this.MutualReceive.bind(this);
    this.MutualTransfer = this.MutualTransfer.bind(this);
    this.Revoke = this.Revoke.bind(this);
    this.Split = this.Split.bind(this);
    this.Transfer = this.Transfer.bind(this);
  }
  Allow(request: DecryptableAllowCoinRequest): Promise<AllowCoinResponse> {
    const data = DecryptableAllowCoinRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Allow", data);
    return promise.then((data) => AllowCoinResponse.decode(new BinaryReader(data)));
  }

  Intersect(request: DecryptableIntersectCoinRequest): Promise<IntersectCoinResponse> {
    const data = DecryptableIntersectCoinRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Intersect", data);
    return promise.then((data) => IntersectCoinResponse.decode(new BinaryReader(data)));
  }

  Merge(request: DecryptableMergeCoinRequest): Promise<MergeCoinResponse> {
    const data = DecryptableMergeCoinRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Merge", data);
    return promise.then((data) => MergeCoinResponse.decode(new BinaryReader(data)));
  }

  Mint(request: DecryptableMintCoinRequest): Promise<MintCoinResponse> {
    const data = DecryptableMintCoinRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Mint", data);
    return promise.then((data) => MintCoinResponse.decode(new BinaryReader(data)));
  }

  MutualReceive(request: DecryptableMutualReceiveCoinRequest): Observable<MutualReceiveCoinResponse> {
    const data = DecryptableMutualReceiveCoinRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "MutualReceive", data);
    return result.pipe(map((data) => MutualReceiveCoinResponse.decode(new BinaryReader(data))));
  }

  MutualTransfer(request: DecryptableMutualTransferCoinRequest): Observable<MutualTransferCoinResponse> {
    const data = DecryptableMutualTransferCoinRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "MutualTransfer", data);
    return result.pipe(map((data) => MutualTransferCoinResponse.decode(new BinaryReader(data))));
  }

  Revoke(request: DecryptableRevokeCoinRequest): Promise<RevokeCoinResponse> {
    const data = DecryptableRevokeCoinRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Revoke", data);
    return promise.then((data) => RevokeCoinResponse.decode(new BinaryReader(data)));
  }

  Split(request: DecryptableSplitCoinRequest): Promise<SplitCoinResponse> {
    const data = DecryptableSplitCoinRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Split", data);
    return promise.then((data) => SplitCoinResponse.decode(new BinaryReader(data)));
  }

  Transfer(request: DecryptableTransferCoinRequest): Promise<TransferCoinResponse> {
    const data = DecryptableTransferCoinRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Transfer", data);
    return promise.then((data) => TransferCoinResponse.decode(new BinaryReader(data)));
  }
}

export interface TransactionService {
  Approve(request: DecryptableApprovePendingTransactionRequest): Promise<ApprovePendingTransactionResponse>;
  Reject(request: DecryptableRejectPendingTransactionRequest): Promise<RejectPendingTransactionResponse>;
}

export const TransactionServiceServiceName = "quilibrium.node.node.pb.TransactionService";
export class TransactionServiceClientImpl implements TransactionService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || TransactionServiceServiceName;
    this.rpc = rpc;
    this.Approve = this.Approve.bind(this);
    this.Reject = this.Reject.bind(this);
  }
  Approve(request: DecryptableApprovePendingTransactionRequest): Promise<ApprovePendingTransactionResponse> {
    const data = DecryptableApprovePendingTransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Approve", data);
    return promise.then((data) => ApprovePendingTransactionResponse.decode(new BinaryReader(data)));
  }

  Reject(request: DecryptableRejectPendingTransactionRequest): Promise<RejectPendingTransactionResponse> {
    const data = DecryptableRejectPendingTransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Reject", data);
    return promise.then((data) => RejectPendingTransactionResponse.decode(new BinaryReader(data)));
  }
}

export interface NodeStats {
  PutNodeInfo(request: PutNodeInfoRequest): Promise<PutResponse>;
  PutPeerInfo(request: PutPeerInfoRequest): Promise<PutResponse>;
}

export const NodeStatsServiceName = "quilibrium.node.node.pb.NodeStats";
export class NodeStatsClientImpl implements NodeStats {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || NodeStatsServiceName;
    this.rpc = rpc;
    this.PutNodeInfo = this.PutNodeInfo.bind(this);
    this.PutPeerInfo = this.PutPeerInfo.bind(this);
  }
  PutNodeInfo(request: PutNodeInfoRequest): Promise<PutResponse> {
    const data = PutNodeInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PutNodeInfo", data);
    return promise.then((data) => PutResponse.decode(new BinaryReader(data)));
  }

  PutPeerInfo(request: PutPeerInfoRequest): Promise<PutResponse> {
    const data = PutPeerInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PutPeerInfo", data);
    return promise.then((data) => PutResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
